#pragma once
#include <string>
/****************************************************************************************/
static std::string shader_source_simple =
"float3              iMouse;\n"
"float4              iResolution;\n"
"float               iTime;\n"
"float               iFrame;\n"
"\n"
"float4 main(): SV_TARGET\n"
"{\n"
"    float4 outColor = (float4)0;\n"
"    float2 fragCoord = float2(iMouse.x, iResolution.y - iMouse.y) + "
"float2(0.5, 0.5);\n"
"    outColor = float4(fragCoord, iTime, iFrame) * iMouse.xyzz;       \n"
"    return outColor;\n"
"}";

/****************************************************************************************/
static std::string shader_source =
"struct RGB {\n"
"  float r;\n"
"  float g;\n"
"  float b;\n"
"};\n"
"\n"
"struct UBO {\n"
"  float4x4  XformMatrix;\n"
"  float3    Scale;\n"
"  RGB       Rgb;\n"
"  float     t;\n"
"  float2    uv; \n"
"};\n"
"\n"
"struct Data {\n"
"  float3  Element_f3;\n"
"  float2  Element_f2;\n"
"};\n"
"\n"
"struct PSInput {\n"
"  float4  Position  : SV_POSITION;\n"
"  float3  Normal    : NORMAL;\n"
"  float3  Color     : COLOR;\n"
"  float   Alpha     : OPACITY;\n"
"  float4  Scaling   : SCALE;\n"
"  float2  TexCoord0 : TEXCOORD0;\n"
"  float2  TexCoord1 : TEXCOORD1;\n"
"  float2  TexCoord2 : TEXCOORD2;\n"
"};\n"
"\n"
"struct PSOutput {\n"
"  float4  oColor0 : SV_TARGET0;\n"
"  float4  oColor1 : SV_TARGET1;\n"
"  float4  oColor2 : SV_TARGET2;\n"
"  float4  oColor3 : SV_TARGET3;\n"
"  float4  oColor4 : SV_TARGET4;\n"
"  float4  oColor5 : SV_TARGET5;\n"
"  float4  oColor6 : SV_TARGET6;\n"
"  float4  oColor7 : SV_TARGET7;\n"
"};\n"
"\n"
"struct myStruct\n"
"{\n"
"    float3 f3;\n"
"\tfloat2 f2;\n"
"};\n"
"\n"
"Texture2D     texture_2d : register(t0, space0); // D3D_SIT_TEXTURE2D\n"
"SamplerState  sampler_ : register(s1, space1); // D3D_SIT_SAMPLER\n"
"ConstantBuffer<UBO> constant_buffer_array[2] : register(b2, space2); // D3D_SIT_CBUFFER\n"
"ConsumeStructuredBuffer<Data> consume_structured_buffer : register(u3, space2); // D3D_SIT_UAV_CONSUME_STRUCTURED\n"
"AppendStructuredBuffer<Data> append_structured_buffer : register(u4, space2); // D3D_SIT_UAV_APPEND_STRUCTURED\n"
"TextureBuffer<myStruct> texture_buffer; // D3D_SIT_TBUFFER\n"
"RWTexture2D<float2>     rw_texture[2]; // D3D_SIT_UAV_RWTYPED\n"
"StructuredBuffer<myStruct> sturctured_buffer; // D3D_SIT_STRUCTURED\n"
"RWStructuredBuffer<myStruct> rw_sturctured_buffer; // D3D_SIT_UAV_RWSTRUCTURED\n"
"ByteAddressBuffer ba_buffer; // D3D_SIT_BYTEADDRESS\n"
"RWByteAddressBuffer rw_ba_buffer; // D3D_SIT_RWBYTEADDRESS\n"
"RWTexture2DArray<float2>     rw_texture_array; // D3D_SIT_UAV_RWTYPED\n"
"Texture2DMS<float4, 128> ms_texture;\n"
"Texture2DMSArray<float4, 64> ms_texture_array;\n"
"Buffer<uint> buffer_int;\n"
"Buffer<uint2> buffer_int2;\n"
"Buffer<uint3> buffer_int3;\n"
"Buffer<uint4> buffer_int4;\n"
"Buffer<float> buffer_float;\n"
"Buffer<float2> buffer_float2;\n"
"Buffer<float3> buffer_float3;\n"
"Buffer<float4> buffer_float4;\n"
"RWBuffer<uint> rw_buffer;\n"
"cbuffer c_buffer : register(b11, space2) { int2 cbuffer_i2; float3 cbuffer_f3; }\n"
"tbuffer t_buffer : register(t15)\n"
"{\n"
"\tfloat3 tbuffer_f3;\n"
"\tuint tbuffer_u1;\n"
"\tint2 tbuffer_i2;\n"
"};\n"
"\n"
"PSOutput main(PSInput input)\n"
"{\n"
"  Data val = consume_structured_buffer.Consume();\n"
"  append_structured_buffer.Append(val);\n"
"  \n"
"  int buffer_value = buffer_int[0] * buffer_int2[0].x * buffer_int3[0].x * buffer_int4[0].x;\n"
"  buffer_value *= (int)(buffer_float[0] * buffer_float2[0].x * buffer_float3[0].x * buffer_float4[0].x);\n"
"  rw_texture[0][uint2(0,0)] = buffer_value;\n"
"  rw_sturctured_buffer[0].f3.x = 1;\n"
"  rw_ba_buffer.Store(1, 1);\n"
"  rw_buffer[0] = (uint)buffer_value;\n"
"  int w,h,n;\n"
"  ms_texture.GetDimensions(w,h,n); \n"
"  int w1,h1,e1,n1;\n"
"  ms_texture_array.GetDimensions(w1,h1,e1,n1); \n"
"  n1 *= texture_buffer.f3.x;\n"
"\n"
"  PSOutput ret;\n"
"  ret.oColor0 = mul(constant_buffer_array[0].XformMatrix, input.Position) * n * n1 * cbuffer_i2.x * tbuffer_f3.x;\n"
"  ret.oColor1 = float4(input.Normal, 1) + float4(constant_buffer_array[0].Scale, 0);\n"
"  ret.oColor2 = float4(input.Color, 1);\n"
"  ret.oColor3 = float4(texture_2d.Sample(sampler_, input.TexCoord0).xyz, input.Alpha);\n"
"  ret.oColor4 = input.Scaling * sturctured_buffer[0].f3.x * ba_buffer.Load(0);\n"
"  ret.oColor5 = float4(input.TexCoord0, 0, 0);\n"
"  ret.oColor6 = float4(input.TexCoord1, 0, 0);\n"
"  ret.oColor7 = float4(input.TexCoord2, 0, 0);\n"
"  return ret;\n"
"}";


/****************************************************************************************/
static std::string shader_array_source =
"#define DM_GFX_HLSL_SPIRV 1\n"
"\n"
"#define DM_GFX_ENTRY_FUNCTION_PS\n"
"\n"
"#ifdef DM_GFX_HLSL_SPIRV\n"
"    #define DM_GFX_VK_LOCATION(location_var) [[vk::location(location_var)]]\n"
"    #define DM_GFX_VK_BINDING(binding_var, set) [[vk::binding(binding_var, set)]]\n"
"    #define DM_GFX_VK_COUNTER_BINDING(location) [[vk::counter_binding(location)]]\n"
"#else\n"
"    #define DM_GFX_VK_LOCATION(location)\n"
"    #define DM_GFX_VK_BINDING(binding, set)\n"
"    #define DM_GFX_VK_COUNTER_BINDING(location)\n"
"#endif\n"
"#define DM_GFX_SHADER_PROFILE 5_1\n"
"#define EVA_ABUFFER_MAX_FRAGMENT_COUNT 8294400\n"
"#define EVA_REGISTER_SRV_MATERIAL_DIFFUSE t0\n"
"#define EVA_REGISTER_SRV_MATERIAL_SURFACE_ATTRIBUTES t1\n"
"#define EVA_REGISTER_SRV_MATERIAL_AMBIENT_OCCLUSION t2\n"
"#define EVA_REGISTER_SRV_MATERIAL_NORMAL t3\n"
"#define EVA_REGISTER_SRV_MATERIAL_LUMINANCE t4\n"
"#define EVA_REGISTER_SRV_MATERIAL_ALPHA t5\n"
"#define EVA_REGISTER_SRV_MATERIAL_NORMAL_AND_DIFFUSE_DETAIL t7\n"
"#define EVA_REGISTER_SRV_MATERIAL_DIFFUSE1 t8\n"
"#define EVA_REGISTER_SRV_MATERIAL_SPECULAR1 t9\n"
"#define EVA_REGISTER_SRV_MATERIAL_NORMAL1 t10\n"
"#define EVA_REGISTER_SRV_MATERIAL_LUMINANCE1 t11\n"
"#define EVA_REGISTER_SRV_MATERIAL_NORMAL_AND_DIFFUSE_DETAIL1 t12\n"
"#define EVA_REGISTER_SRV_MATERIAL_RGBA_BLEND_MAP t13\n"
"#define EVA_REGISTER_SRV_MATERIAL_RGBA_DIFFUSE_TEXTURES t14\n"
"#define EVA_REGISTER_SRV_MATERIAL_RGBA_ATTRIBUTE_TEXTURES t18\n"
"#define EVA_REGISTER_SRV_MATERIAL_RGBA_NORMAL_TEXTURES t22\n"
"#define EVA_REGISTER_SAMPLER_SURFACE s0\n"
"#define EVA_REGISTER_CBV_VIEW b1\n"
"#define EVA_REGISTER_CBV_GLOBAL b0\n"
"#define EVA_REGISTER_CBV_MEDIUM b5\n"
"#define EVA_REGISTER_CBV_MATERIAL b2\n"
"#define EVA_REGISTER_CBV_TESSELLATION b4\n"
"#define EVA_REGISTER_CBV_TRANSFORMER b3\n"
"#define EVA_REGISTER_SPACE_ILLUMINATION space1\n"
"#define EVA_PER_TILE_CULLING_LIGHT_COUNTERS 3\n"
"#define EVA_PER_TILE_CULLING_CONSTANTS_ELEMENTS 2\n"
"#define EVA_MAX_FRUSTUM_LIGHT_COUNT 292\n"
"#define EVA_MAX_TILE_FRUSTUM_LIGHTS 200\n"
"#define EVA_MAX_TILE_OMNI_LIGHTS 200\n"
"#define EVA_MAX_TILE_REFLECTION_CAPTURERS 256\n"
"#define EVA_OMNI_PER_TILE_ELEMENTS 305\n"
"#define EVA_FRUSTUM_PER_TILE_ELEMENTS 303\n"
"#define EVA_REFLECTION_PER_TILE_ELEMENTS 259\n"
"#define EVA_SAMPLE_COUNT 1\n"
"\n"
"struct PixelInput\n"
"{\n"
"    DM_GFX_VK_LOCATION(0) float4 Position : SV_Position0;\n"
"    DM_GFX_VK_LOCATION(1) float2 TexCoord : TexCoord0;\n"
"    DM_GFX_VK_LOCATION(2) float3 EyeDirectionInView : EyeDirectionInView0;\n"
"    DM_GFX_VK_LOCATION(3) float3 TangentInView : TangentInView0;\n"
"    DM_GFX_VK_LOCATION(4) float3 BitangentInView : BitangentInView0;\n"
"    DM_GFX_VK_LOCATION(5) float3 NormalInView : NormalInView0;\n"
"    DM_GFX_VK_LOCATION(6) float3 EyeDirectionInWorld : EyeDirectionInWorld0;\n"
"    DM_GFX_VK_LOCATION(7) float3 PositionInView : PositionInView0;\n"
"};\n"
"\n"
"struct PixelOutput\n"
"{\n"
"};\n"
"\n"
"DM_GFX_VK_BINDING(0, 3) cbuffer MaterialConstants : register(EVA_REGISTER_CBV_MATERIAL)\n"
"{\n"
"    float2 UVScale;\n"
"    float2 UVOffset;\n"
"    float3 DiffuseColor;\n"
"    float AlphaTestTolerance;\n"
"    float3 LuminanceNormalColor;\n"
"    float LuminanceInterpolationExponent;\n"
"    float3 LuminanceGrazingColor;\n"
"    float Transparency;\n"
"    float4 DiffuseAndNormalWeightsAndTiling;\n"
"    float4 FadeOutStartAndLength;\n"
"    float3 GlassColor;\n"
"    float GlassReflectionIntensity;\n"
"    float4 RgbaBlendDiffuseColor_UVTileMultiplier[4];\n"
"    float4 RgbaBlendUVOffset[4];\n"
"};\n"
"\n"
"#define EVA_NO_UV_ANIMATION\n"
"#line 2 \"material_uv_animation.hlsl\"\n"
"#ifndef EVA_GEOMETRY_MATERIAL_UV_ANIMATION_HLSL\n"
"#define EVA_GEOMETRY_MATERIAL_UV_ANIMATION_HLSL\n"
"\n"
"// UV Animation\n"
"\n"
"#if defined(EVA_UV_ANIMATION)\n"
"\n"
"// Inputs:\n"
"// float2 TexCoord : TexCoord;\n"
"//\n"
"// Constants:\n"
"// float3 UVScale;\n"
"// float3 UVOffset;\n"
"//\n"
"void EvaluateUVAnimation(\n"
"    inout PixelInput input)\n"
"{\n"
"    input.TexCoord.xy = input.TexCoord.xy * UVScale + UVOffset;\n"
"}\n"
"\n"
"#endif // EVA_UV_ANIMATION\n"
"\n"
"#if defined(EVA_NO_UV_ANIMATION)\n"
"// Inputs: None\n"
"// Outputs: None\n"
"// Constants: None\n"
"//\n"
"void EvaluateUVAnimation(\n"
"    inout PixelInput input)\n"
"{\n"
"}\n"
"#endif // defined(EVA_NO_UV_ANIMATION)\n"
"\n"
"#endif\n"
"#define EVA_NO_ALPHA_TEST\n"
"#line 2 \"material_alpha_test.hlsl\"\n"
"#ifndef EVA_GEOMETRY_MATERIAL_ALPHA_TEST_HLSL\n"
"#define EVA_GEOMETRY_MATERIAL_ALPHA_TEST_HLSL\n"
"\n"
"// Alpha testing\n"
"\n"
"#if defined(EVA_ALPHA_TEST) && !defined(EVA_MULTISAMPLE_ENABLED) \n"
"\n"
"// Inputs:\n"
"// float2 TexCoord : TexCoord;\n"
"//\n"
"DM_GFX_VK_BINDING(6, 3)\n"
"Texture2D<float> AlphaTexture : register(EVA_REGISTER_SRV_MATERIAL_ALPHA);\n"
"\n"
"void ApplyAlphaTestClipping(\n"
"    PixelInput input,\n"
"    inout PixelOutput output,\n"
"    out uint coverage)\n"
"{\n"
"    // TODO Juha: Apply dithering to alpha.\n"
"    \n"
"    float alphaTexel = AlphaTexture.Sample(SurfaceSampler, input.TexCoord.xy) - 0.5f;\n"
"    // Using clip() instead of outputting SV_Coverage is potentially faster.\n"
"    // clip() not supported in SPIR-V CodeGen currently\n"
"    clip(alphaTexel);\n"
"\n"
"    uint bit;\n"
"    // SPIR-V CodeGen bug: (alphaTexel > 0.0) ? 1 : 0 doesn't work\n"
"    if (alphaTexel > 0.0)\n"
"        bit = 1;\n"
"    else\n"
"        bit = 0;\n"
"\n"
"    coverage = bit;\n"
"}\n"
"\n"
"#endif // EVA_ALPHA_TEST && !EVA_MULTISAMPLE_ENABLED\n"
"\n"
"#if defined(EVA_ALPHA_TEST) && defined(EVA_MULTISAMPLE_ENABLED)\n"
"\n"
"// Inputs:\n"
"// float2 TexCoord : TexCoord;\n"
"// uint coverage : SV_Coverage;\n"
"//\n"
"// Outputs:\n"
"// uint coverage : SV_Coverage;\n"
"//\n"
"DM_GFX_VK_BINDING(6, 3)\n"
"Texture2D<float> AlphaTexture : register(EVA_REGISTER_SRV_MATERIAL_ALPHA);\n"
"\n"
"void ApplyAlphaTestClipping(\n"
"    PixelInput input,\n"
"    PixelOutput outputPixel,\n"
"    out uint coverage)\n"
"{\n"
"    uint inputCoverage = input.coverage;\n"
"    uint output = 0;\n"
"\n"
"    [unroll]\n"
"    for (uint i = 0; i < EVA_SAMPLE_COUNT; ++i)\n"
"    {\n"
"        float2 texcoordAtSample = EvaluateAttributeAtSample(input.TexCoord.xy, i);\n"
"        float texel = AlphaTexture.Sample(SurfaceSampler, texcoordAtSample);\n"
"        uint bit = (texel > 0.5f); \n"
"        output |= bit << i;\n"
"    }\n"
"    \n"
"    coverage = inputCoverage & output;\n"
"    outputPixel.coverage = coverage;;\n"
"}\n"
"\n"
"#endif // defined(EVA_ALPHA_TEST) && defined(EVA_MULTISAMPLE_ENABLED)\n"
"\n"
"#if defined(EVA_NO_ALPHA_TEST) && !defined(EVA_MULTISAMPLE_ENABLED) \n"
"// Inputs: None\n"
"// Outputs: None\n"
"// Constants: None\n"
"//\n"
"void ApplyAlphaTestClipping(PixelInput input, PixelOutput output, out uint coverage)\n"
"{\n"
"    coverage = 1;\n"
"}\n"
"#endif // defined(EVA_NO_ALPHA_TEST) && !defined(EVA_MULTISAMPLE_ENABLED)\n"
"\n"
"#if defined(EVA_NO_ALPHA_TEST) && defined(EVA_MULTISAMPLE_ENABLED)\n"
"// Inputs:\n"
"// uint coverage : SV_Coverage;\n"
"//\n"
"// Outputs: None\n"
"// Constants: None\n"
"//\n"
"void ApplyAlphaTestClipping(PixelInput input, PixelOutput output, out uint coverage)\n"
"{\n"
"    coverage = input.coverage;\n"
"}\n"
"#endif // defined(EVA_NO_ALPHA_TEST) && defined(EVA_MULTISAMPLE_ENABLED)\n"
"\n"
"#endif\n"
"#define EVA_NO_LUMINANCE\n"
"#line 2 \"material_luminance.hlsl\"\n"
"#ifndef EVA_GEOMETRY_MATERIAL_LUMINANCE_HLSL\n"
"#define EVA_GEOMETRY_MATERIAL_LUMINANCE_HLSL\n"
"\n"
"// Luminance\n"
"\n"
"#ifdef EVA_LUMINANCE\n"
"// Inputs:\n"
"// float2 TexCoord : TexCoord;\n"
"// float3 EyeDirectionInView : EyeDirectionInView;\n"
"// float3 PositionInWorld : PositionInWorld;\n"
"//\n"
"// Outputs:\n"
"// float3 SurfaceIllumination : SV_Target3;\n"
"//\n"
"// Constants:\n"
"// float3 LuminanceNormalColor;\n"
"// float LuminanceInterpolationExponent;\n"
"// float3 LuminanceGrazingColor;\n"
"//\n"
"// Notes:\n"
"// normalInView is provided from ApplySurfaceShading function.\n"
"//\n"
"\n"
"DM_GFX_VK_BINDING(5, 3)\n"
"Texture2D<float3> LuminanceTexture : register(EVA_REGISTER_SRV_MATERIAL_LUMINANCE);\n"
"DM_GFX_VK_BINDING(10, 3)\n"
"Texture2D<float3> LuminanceTexture1 : register(EVA_REGISTER_SRV_MATERIAL_LUMINANCE1);\n"
"//Texture2D<float3> MagmaManLuminanceTexture;\n"
"\n"
"void ApplyLuminance(\n"
"    PixelInput input,\n"
"    float3 normalInView,\n"
"    inout PixelOutput output)\n"
"{\n"
"/*#ifndef EVA_DOUBLE_SIDED_SURFACE_SHADING\n"
"    if (!input.IsFrontFace)\n"
"    {\n"
"        output.SurfaceIllumination = 0.0;\n"
"        return;\n"
"    }\n"
"#endif*/\n"
"\n"
"    float3 V = normalize(input.EyeDirectionInView);\n"
"    float lerpFactor = pow(1 - saturate(dot(normalInView, V)), LuminanceInterpolationExponent);\n"
"    float3 luminanceColor = lerp(LuminanceNormalColor, LuminanceGrazingColor, lerpFactor);\n"
"    \n"
"#ifdef EVA_TEXTURE_BLENDING\n"
"    float3 luminanceTexel0 = LuminanceTexture.Sample(SurfaceSampler, input.TexCoords.xy);\n"
"    float3 luminanceTexel1 = LuminanceTexture1.Sample(SurfaceSampler, input.TexCoords.zw);\n"
"    float3 luminanceTexel = lerp(luminanceTexel0, luminanceTexel1, input.Color_BlendFactor.w);\n"
"    float3 luminance = luminanceTexel * luminanceColor;\n"
"#else\n"
"    #ifdef EVA_PORTAL_LUMINANCE\n"
"    // Portal texture is the same size as the main texture, so can load directly from the\n"
"    // same position. Effectively this texturing happens in the screen space coordinates.\n"
"    float3 luminanceTexel = LuminanceTexture[input.Position.xy];\n"
"    #else\n"
"    float3 luminanceTexel = LuminanceTexture.Sample(SurfaceSampler, input.TexCoord.xy);\n"
"    #endif\n"
"\n"
"    float3 luminance = luminanceTexel * luminanceColor;\n"
"#endif\n"
"        \n"
"    output.SurfaceIllumination.xyz += luminance;\n"
"    //output.SurfaceIllumination.w = 0;\n"
"    output.SurfaceIllumination = max(output.SurfaceIllumination, 0);\n"
"}\n"
"\n"
"#endif\n"
"\n"
"#ifdef EVA_NO_LUMINANCE\n"
"// Inputs: None\n"
"// Outputs: None\n"
"//\n"
"// Constants: None\n"
"void ApplyLuminance(\n"
"    PixelInput input,\n"
"    float3 normalInView,\n"
"    inout PixelOutput output)\n"
"{\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"#define EVA_GLASS_SURFACE_SHADING\n"
"/*\n"
" * High-level culling documentation at Google sites under engine/Illumination!\n"
" *\n"
" * About culling buffers:\n"
" * \n"
" * Culling is done to two bins by default; near and far.\n"
" * In addition, indices of volume-affecting lights are written\n"
" * to a separate bin.\n"
" *\n"
" * Buffer layout looks like this for omni/frustum lights:\n"
" *\n"
" * [Tile data][Tile data]...\n"
" *\n"
" * Each Tile data -block contains following:\n"
" *                                                          EVA_MAX_(FRUSTUM|OMNI)_PER_TILE_LIGHTS\n"
" * | uint        | uint       | uint          | 0... max tile lights * uint | max_tile_volume lights * uint |\n"
" * [Near counter][Far counter][Volume counter][Near bin ->  ] [  <- Far bin ][Volume lights]\n"
" *\n"
" * Note that near/far bins share (kind of) the same data block.\n"
" *\n"
" * In addition, every omni light list contains a few constants at the beginning of tile data:\n"
" * - half Z\n"
" */\n"
"\n"
"struct CullingBufferOffsets\n"
"{\n"
"    // Base offset to per-tile data\n"
"    uint tileBaseOffset;\n"
"    // Offset to light bin start\n"
"    uint tileLightBins;\n"
"    // Offset to counter values\n"
"    uint tileLightCounters;\n"
"};\n"
"\n"
"struct WritableCullingData\n"
"{\n"
"    CullingBufferOffsets offsets;\n"
"    RWBuffer<uint> buffer;\n"
"};\n"
"\n"
"struct ReadableCullingData\n"
"{\n"
"    CullingBufferOffsets offsets;\n"
"    \n"
"    // For convenience, there's extra data in this struct.\n"
"    // Does not generate more complex assembly, but makes\n"
"    // code easier to understand.\n"
"    uint nearStartIndex;\n"
"    uint nearEndIndex;\n"
"    \n"
"    uint farStartIndex;\n"
"    uint farEndIndex;\n"
"\n"
"    uint volumeStartIndex;\n"
"    uint volumeEndIndex;\n"
"    \n"
"    uint lightsPerTile;\n"
"    \n"
"    Buffer<uint> buffer;\n"
"};\n"
"\n"
"struct CullingTileConstants\n"
"{\n"
"    float halfZ;\n"
"};\n"
"\n"
"void Culling_SaveTileConstants(WritableCullingData omniData, float halfZ)\n"
"{\n"
"    uint uHalfZ = asuint(halfZ);\n"
"    omniData.buffer[omniData.offsets.tileBaseOffset + 0] = uHalfZ >> 16;\n"
"    omniData.buffer[omniData.offsets.tileBaseOffset + 1] = uHalfZ & 0xFFFF;\n"
"}\n"
"\n"
"WritableCullingData Culling_InitCulling(RWBuffer<uint> buffer, uint tileIndex, const uint elementsPerTile, uint lightDataOffset)\n"
"{\n"
"    CullingBufferOffsets offsets;\n"
"    offsets.tileBaseOffset = tileIndex * elementsPerTile;\n"
"    offsets.tileLightCounters = offsets.tileBaseOffset + lightDataOffset;\n"
"    offsets.tileLightBins = offsets.tileLightCounters + EVA_PER_TILE_CULLING_LIGHT_COUNTERS;\n"
"\n"
"    WritableCullingData dataOmni;\n"
"    dataOmni.offsets = offsets;\n"
"    dataOmni.buffer = buffer;\n"
"    return dataOmni;\n"
"}\n"
"\n"
"ReadableCullingData _Culling_LoadData(Buffer<uint> buffer, uint tileIndex, uint elementsPerTile, uint lightsPerTile, uint lightDataOffset)\n"
"{\n"
"    CullingBufferOffsets offsets;\n"
"    offsets.tileBaseOffset = tileIndex * elementsPerTile;\n"
"    offsets.tileLightCounters = offsets.tileBaseOffset + lightDataOffset;\n"
"    offsets.tileLightBins = offsets.tileLightCounters + EVA_PER_TILE_CULLING_LIGHT_COUNTERS;\n"
"    \n"
"    ReadableCullingData readable;\n"
"    readable.buffer = buffer;\n"
"    readable.offsets = offsets;\n"
"    readable.lightsPerTile = lightsPerTile;\n"
"    \n"
"    readable.nearStartIndex = 0;\n"
"    readable.nearEndIndex = buffer[offsets.tileLightCounters + 0];\n"
"    \n"
"    readable.farStartIndex = buffer[offsets.tileLightCounters + 1];\n"
"    readable.farEndIndex = lightsPerTile;\n"
"    \n"
"    readable.volumeStartIndex = lightsPerTile;\n"
"    readable.volumeEndIndex = buffer[offsets.tileLightCounters + 2];\n"
"    return readable;\n"
"}\n"
"\n"
"\n"
"void Culling_SaveLightIndex(WritableCullingData data, uint indexInTile, uint index)\n"
"{\n"
"    data.buffer[data.offsets.tileLightBins + indexInTile] = index;\n"
"}\n"
"\n"
"uint Culling_LoadLightIndex(ReadableCullingData data, uint indexInTile)\n"
"{\n"
"    return data.buffer[data.offsets.tileLightBins + indexInTile];\n"
"}\n"
"\n"
"void Culling_SelectBin(ReadableCullingData data, CullingTileConstants constants, float Z, out uint startIndex, out uint endIndex)\n"
"{\n"
"    // Note: depth values are negative, so step arguments are backwards.\n"
"    uint bin = step(Z, constants.halfZ);\n"
"    \n"
"    // Calculate indices so near bin iterates between [0, nearEndIndex[\n"
"    // and far bin between [farStartIndex, farEndIndex[\n"
"    startIndex = bin * data.farStartIndex;\n"
"    endIndex = data.nearEndIndex + bin * (data.farEndIndex - data.nearEndIndex);\n"
"}\n"
"\n"
"void Culling_SaveLightCounters(WritableCullingData data, uint nearCounter, uint farCounter, uint volumeCounter)\n"
"{\n"
"    data.buffer[data.offsets.tileLightCounters + 0] = nearCounter;\n"
"    data.buffer[data.offsets.tileLightCounters + 1] = farCounter;\n"
"    data.buffer[data.offsets.tileLightCounters + 2] = volumeCounter;\n"
"}\n"
"\n"
"void Culling_SaveReflectionTileConstants();\n"
"\n"
"\n"
"// THESE FUNCTIONS DEPEND ON DEFINES!\n"
"// They kind of break the pure functional rules, but are much more convenient\n"
"// to use from multiple places...\n"
"\n"
"CullingTileConstants Culling_LoadTileConstants(Buffer<uint> buffer, uint tileIndex)\n"
"{\n"
"    CullingTileConstants constants;\n"
"    // constants in omni buffer\n"
"    uint uHalfZ = \n"
"        buffer[tileIndex * EVA_OMNI_PER_TILE_ELEMENTS + 0] << 16 |\n"
"        buffer[tileIndex * EVA_OMNI_PER_TILE_ELEMENTS + 1];\n"
"    constants.halfZ = asfloat(uHalfZ);\n"
"    return constants;\n"
"}\n"
"\n"
"ReadableCullingData Culling_LoadOmniData(Buffer<uint> buffer, uint tileIndex)\n"
"{\n"
"    return _Culling_LoadData(buffer, tileIndex, EVA_OMNI_PER_TILE_ELEMENTS, EVA_MAX_TILE_OMNI_LIGHTS, EVA_PER_TILE_CULLING_CONSTANTS_ELEMENTS);\n"
"}\n"
"\n"
"ReadableCullingData Culling_LoadFrustumData(Buffer<uint> buffer, uint tileIndex)\n"
"{\n"
"    return _Culling_LoadData(buffer, tileIndex, EVA_FRUSTUM_PER_TILE_ELEMENTS, EVA_MAX_TILE_FRUSTUM_LIGHTS, 0);\n"
"}\n"
"\n"
"ReadableCullingData Culling_LoadReflectionCapturerData(Buffer<uint> buffer, uint tileIndex)\n"
"{\n"
"    return _Culling_LoadData(buffer, tileIndex, EVA_REFLECTION_PER_TILE_ELEMENTS, EVA_MAX_TILE_REFLECTION_CAPTURERS, 0);\n"
"}\n"
"#ifndef EVA_LIBRARY_CUBEMAP_HLSL\n"
"#define EVA_LIBRARY_CUBEMAP_HLSL\n"
"\n"
"// Functions for sampling from right-handed cube shots.\n"
"// API assumes cube shot is in left-handed coordinates, so we must flip Z when sampling.\n"
"// See the documentation for more info.\n"
"\n"
"float4 Cubemap_SampleLevelRH(TextureCube<float4> cube, SamplerState samplerstate, float3 direction, float lod)\n"
"{\n"
"\tdirection.z = -direction.z;\n"
"\treturn cube.SampleLevel(samplerstate, direction, lod);\n"
"}\n"
"\n"
"#endif\n"
"//! include \"view_gbuffer.hlsl\"\n"
"//! include \"culling.hlsl\"\n"
"//! include \"cubemap.hlsl\"\n"
"\n"
"struct PackedReflectionCapturerData\n"
"{\n"
"    float3 PositionInView;\n"
"    uint Radius_TextureArrayIndex_MipCount;\n"
"};\n"
"\n"
"struct ReflectionCapturerData\n"
"{\n"
"    float3 PositionInView;\n"
"    float Radius;\n"
"    uint TextureArrayIndex;\n"
"    uint MipCount;\n"
"};\n"
"\n"
"struct SurfaceAttributes\n"
"{\n"
"    float Depth;\n"
"    float3 PositionInView;\n"
"\n"
"    float3 Normal;\n"
"    float Roughness; // 0: smooth 1: rough\n"
"};\n"
"\n"
"ReflectionCapturerData UnpackReflectionCapturerData(PackedReflectionCapturerData p)\n"
"{\n"
"    ReflectionCapturerData r;\n"
"    r.PositionInView = p.PositionInView;\n"
"    r.Radius = f16tof32(p.Radius_TextureArrayIndex_MipCount >> 16);\n"
"    r.TextureArrayIndex = (p.Radius_TextureArrayIndex_MipCount >> 8) & 0xff;\n"
"    r.MipCount = p.Radius_TextureArrayIndex_MipCount & 0xff;\n"
"    return r;\n"
"}\n"
"\n"
"float4 SampleCubeReflections(\n"
"    float4x4 viewToWorldMatrix,\n"
"    float3 reflectionDirection,\n"
"    ReflectionCapturerData capturer, \n"
"    SurfaceAttributes surface,\n"
"    TextureCube<float4> reflectionCapturerCubes[64],\n"
"    SamplerState reflectionCapturerSampler)\n"
"{\n"
"    float3 capturerToSurfaceVector = surface.PositionInView - capturer.PositionInView;\n"
"    float captureDistance = length(capturerToSurfaceVector);\n"
"    float3 capturerToSurfaceDirection = normalize(capturerToSurfaceVector);\n"
"    \n"
"    // Compiler requires this temporary variable; returning values\n"
"    // directly from inside of a nested if doesn't compile without warnings in this case!\n"
"    float4 colorAndFade = (float4)0.f;\n"
"    \n"
"    if (captureDistance < capturer.Radius)\n"
"    {\n"
"        float3 rayDirection = reflectionDirection * capturer.Radius;\n"
"        float radiusSqr = capturer.Radius * capturer.Radius;\n"
"        float captureDirectionSqr = dot(capturerToSurfaceDirection, capturerToSurfaceDirection);\n"
"\n"
"        // ray & sphere intersection\n"
"        float a = dot(rayDirection, rayDirection);\n"
"        float b = 2 * dot(rayDirection, capturerToSurfaceDirection);\n"
"        float c = captureDirectionSqr - radiusSqr;\n"
"        float D = b * b - 4 * a * c;\n"
"        \n"
"        if (D >= 0)\n"
"        { \n"
"            float farIntersection = (sqrt(D) - b) * rcp(2 * max(a, 0.0001f));\n"
"            float3 intersectPosition = surface.PositionInView + farIntersection * rayDirection;\n"
"            float3 projectedDirection = intersectPosition - capturer.PositionInView;\n"
"            // Sphere edge is smoothly faded away\n"
"            float distanceFade = 1.0f - smoothstep(0.9, 1.0, captureDistance / capturer.Radius);\n"
"            \n"
"            float lod = surface.Roughness * capturer.MipCount;\n"
"            // Projected direction is at this point in view space. We must convert\n"
"            // to world space in order to sample the correct cube face.\n"
"            // TODO: is there a way to not do this per sample?\n"
"\n"
"            // SPIR-V CodeGen workaround: cannot assign anything colorAndFade, result will be always zero!\n"
"            // must return directly\n"
"            float3 color = Cubemap_SampleLevelRH(reflectionCapturerCubes[NonUniformResourceIndex(capturer.TextureArrayIndex)],\n"
"                reflectionCapturerSampler, mul((float3x3)viewToWorldMatrix, projectedDirection), lod).xyz;\n"
"            colorAndFade = float4(color, distanceFade);\n"
"        }\n"
"    }\n"
"\n"
"    return colorAndFade;\n"
"}\n"
"\n"
"float3 AccumulateReflections(\n"
"    uint flattenedTileIndex,\n"
"    float4x4 viewToWorldMatrix,\n"
"    SurfaceAttributes surface,\n"
"    SamplerState reflectionCapturerSampler,\n"
"    Buffer<uint> tiledCullingConstantsAndOmniBuffer,\n"
"    Buffer<uint> tiledCullingReflectionBuffer,\n"
"    TextureCube<float4> reflectionCapturerCubes[64],\n"
"    StructuredBuffer<PackedReflectionCapturerData> reflectionCapturerBuffer\n"
")\n"
"{\n"
"    float3 eyeDirectionInView = normalize(surface.PositionInView);\n"
"    float3 reflectionDirection = reflect(eyeDirectionInView, surface.Normal);\n"
"\n"
"    CullingTileConstants cullingConstants = Culling_LoadTileConstants(tiledCullingConstantsAndOmniBuffer, flattenedTileIndex);\n"
"    ReadableCullingData omniData = Culling_LoadReflectionCapturerData(tiledCullingReflectionBuffer, flattenedTileIndex);\n"
"\n"
"    float4 AccumulatedReflection = float4(0.0f, 0.0f, 0.0f, 0.0f);\n"
"    float distanceFade = 1.0;\n"
"    uint startIndex, endIndex, i;\n"
"    Culling_SelectBin(omniData, cullingConstants, surface.PositionInView.z, startIndex, endIndex);\n"
"    \n"
"    float3 reflection = 0.f;\n"
"    for (i = startIndex; i < endIndex; i++)\n"
"    {\n"
"        uint capturerIndex = Culling_LoadLightIndex(omniData, i);\n"
"        ReflectionCapturerData capturer = UnpackReflectionCapturerData(reflectionCapturerBuffer[capturerIndex]);\n"
"        float4 reflection = SampleCubeReflections(viewToWorldMatrix, reflectionDirection, capturer, surface, reflectionCapturerCubes, reflectionCapturerSampler);\n"
"        \n"
"        AccumulatedReflection += float4(reflection.xyz * reflection.w, reflection.w);\n"
"    }\n"
"    \n"
"    //return (float3)(AccumulatedReflection.w / max(0.0, AccumulatedReflection.w) * smoothstep(0., 0.1, AccumulatedReflection.w));\n"
"    // Smoothstep makes reflections fade correctly\n"
"    return AccumulatedReflection.xyz / max(0.01, AccumulatedReflection.w) * smoothstep(0., 0.1, AccumulatedReflection.w);\n"
"}\n"
"#line 2 \"surface_sampler.hlsl\"\n"
"\n"
"#ifndef EVA_GEOMETRY_SURFACE_SAMPLER_HLSL\n"
"#define EVA_GEOMETRY_SURFACE_SAMPLER_HLSL\n"
"\n"
"// This can be bilinear, trilinear or anisotropic\n"
"DM_GFX_VK_BINDING(0, 0)\n"
"SamplerState SurfaceSampler : register(EVA_REGISTER_SAMPLER_SURFACE);\n"
"\n"
"#endif\n"
"#line 2 \"global_constants.hlsl\"\n"
"#ifndef EVA_GEOMETRY_GLOBAL_CONSTANTS_HLSL\n"
"#define EVA_GEOMETRY_GLOBAL_CONSTANTS_HLSL\n"
"\n"
"#if 0 // not used\n"
"cbuffer GlobalConstants : register(EVA_REGISTER_CBV_GLOBAL)\n"
"{\n"
"    uint FullCoverage;\n"
"    float3 FogColor;\n"
"    float OneOverFogDistance;\n"
"    int OmniLightCount;\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"#line 2 \"view_gbuffer.hlsl\"\n"
"#ifndef EVA_VIEW_HLSL\n"
"#define EVA_VIEW_HLSL\n"
"\n"
"// Data definitions\n"
"\n"
"struct ViewConstantsStruct\n"
"{\n"
"    float4x4 WorldToViewClipMatrix;\n"
"    float4x4 PreviousWorldToViewClipMatrix;\n"
"    float4x4 WorldToViewMatrix;\n"
"    float4x4 ViewToWorldMatrix;\n"
"    float4x4 ViewToViewClipMatrix;\n"
"    float4x4 ViewClipToViewMatrix;\n"
"    float4x4 ViewportToViewMatrix;\n"
"    float4x4 ViewToTargetMatrix;\n"
"    float4x4 EnvironmentReflectionViewToWorldMatrix;\n"
"\n"
"    float4 LeftViewClipPlane;\n"
"    float4 RightViewClipPlane;    \n"
"    float4 BottomViewClipPlane;\n"
"    float4 TopViewClipPlane;\n"
"\n"
"    float2 TargetSize;\n"
"    float2 OneOverTargetSize;\n"
"    float2 ViewZNormalizationScaleBias;\n"
"    float3 EyePositionInWorld;\n"
"    float ViewHeightToTexelsScale;\n"
"    float2 ViewDistanceToWScaleBias;\n"
"    float2 ZProjection;\n"
"};\n"
"\n"
"#ifdef DM_GFX_HLSL_SPIRV\n"
"DM_GFX_VK_BINDING(0, 1)\n"
"ConstantBuffer<ViewConstantsStruct> ViewConstants;\n"
"#endif\n"
"\n"
"// Functions\n"
"\n"
"// SPIRV CodeGen workarounds\n"
"#ifdef DM_GFX_HLSL_SPIRV\n"
"\n"
"#define GetTargetToViewMatrix(view) \\\n"
"    ((view).ViewportToViewMatrix)\n"
"\n"
"#define GetPositionInTexture(view, positionInTarget) \\\n"
"    ((positionInTarget) * (view).OneOverTargetSize)\n"
"\n"
"#define ZInView(view, depth) \\\n"
"    (-1.0f / ((depth) *  (view).ViewportToViewMatrix._43 +  (view).ViewportToViewMatrix._44))\n"
"\n"
"#else\n"
"\n"
"float4x4 GetTargetToViewMatrix(ViewConstantsStruct view)\n"
"{\n"
"    return view.ViewportToViewMatrix;\n"
"}\n"
"\n"
"float2 GetPositionInTexture(ViewConstantsStruct view, float2 positionInTarget)\n"
"{\n"
"    return positionInTarget * view.OneOverTargetSize;\n"
"}\n"
"\n"
"float ZInView(ViewConstantsStruct view, float depth)\n"
"{\n"
"    return -1.0f / (depth *  view.ViewportToViewMatrix._43 +  view.ViewportToViewMatrix._44);\n"
"}\n"
"\n"
"#endif\n"
"\n"
"\n"
"#endif\n"
"//! include \"view.hlsl\"\n"
"\n"
"// Adds global ViewConstants constant buffer\n"
"\n"
"#ifndef EVA_GEOMETRY_VIEW_CONSTANTS_HLSL\n"
"#define EVA_GEOMETRY_VIEW_CONSTANTS_HLSL\n"
"\n"
"#ifndef EVA_REGISTER_SPACE_VIEW\n"
"#define EVA_REGISTER_SPACE_VIEW space0\n"
"#endif\n"
"\n"
"// Resources\n"
"\n"
"// With Vulkan the constants are defined directly in view.hlsl or view_gbuffer.hlsl\n"
"#ifndef DM_GFX_HLSL_SPIRV\n"
"ConstantBuffer<ViewConstantsStruct> ViewConstants : register(EVA_REGISTER_CBV_VIEW, EVA_REGISTER_SPACE_VIEW);\n"
"#endif\n"
"\n"
"#endif // EVA_GEOMETRY_VIEW_CONSTANTS_HLSL\n"
"#line 2 \"abuffer_fragment.hlsl\"\n"
"\n"
"// Note: size must match with ABufferFragment in eva/graphics/rendering/abuffer.h!\n"
"// DO NOT MANIPULATE DIRECTLY - USE THE FUNCTIONS BELOW INSTEAD!\n"
"struct ABufferFragment\n"
"{\n"
"    // 4xhalf float\n"
"    uint2 colorAndAlpha16Bit;\n"
"    \n"
"    // Note: this could also be packed to 3 bytes.\n"
"    uint nextPointer;\n"
"    \n"
"    // Depth could be packed to 16/24 bits.\n"
"    float depth;\n"
"};\n"
"\n"
"/* Packs & stores all data into A-buffer fragment */\n"
"ABufferFragment PackABufferFragment(float3 color, float alpha, float depth)\n"
"{\n"
"    ABufferFragment fragment;\n"
"    fragment.colorAndAlpha16Bit.r = \n"
"        (f32tof16(color.r) << 16) | f32tof16(color.g);\n"
"    fragment.colorAndAlpha16Bit.g = \n"
"        (f32tof16(color.b) << 16) | f32tof16(alpha);\n"
"\n"
"    fragment.depth = depth; \n"
"    \n"
"    // Note: pointer is not written here. Instead, it's done\n"
"    // in StoreABufferFragment.\n"
"        \n"
"    return fragment;\n"
"}\n"
"\n"
"/* Unpacks packed A-buffer fragment data */\n"
"void UnpackABufferFragment(ABufferFragment fragment, out float3 color, out float alpha)\n"
"{\n"
"    color = float3(\n"
"        f16tof32(fragment.colorAndAlpha16Bit.r >> 16),\n"
"        f16tof32(fragment.colorAndAlpha16Bit.r & 0xFFFF),\n"
"        f16tof32(fragment.colorAndAlpha16Bit.g >> 16));\n"
"        \n"
"    alpha = f16tof32(fragment.colorAndAlpha16Bit.g & 0xFFFF);   \n"
"}\n"
"\n"
"/* Stores a fragment into given buffer and updates head pointer with atomics */\n"
"void StoreABufferFragment(\n"
"    uint2 texelPosition, uint targetWidth, \n"
"    ABufferFragment fragment, \n"
"    RWByteAddressBuffer fragmentBufferCounter,\n"
"    RWStructuredBuffer<ABufferFragment> fragmentBuffer, \n"
"    RWByteAddressBuffer headPointerBuffer)\n"
"{\n"
"#ifndef DM_GFX_HLSL_SPIRV\n"
"    uint maxFragmentCount = 0;\n"
"    uint fragmentStride = 0;\n"
"    fragmentBuffer.GetDimensions(maxFragmentCount, fragmentStride);\n"
"#else\n"
"    uint maxFragmentCount = EVA_ABUFFER_MAX_FRAGMENT_COUNT;\n"
"#endif\n"
" \n"
"    // Flatten index\n"
"    uint buffer_pointer = texelPosition.x + targetWidth * texelPosition.y;\n"
"\n"
"    // Link fragment\n"
"\n"
"    // SPIRV CodeGen does not support wave operations yet, so\n"
"    // disable this optimization when SPIR-V is used\n"
"    // This had to be completely disabled due to a likely bug in NVIDIA drivers\n"
"#if 0//defined(DM_GFX_HLSL_COMPILER_DXC) && !defined(DM_GFX_HLSL_SPIRV)\n"
"    // This optimization alleviates atomic contention and ensures that fragments\n"
"    // near each other will be close to each other in the fragment buffer,\n"
"    // at least on certain GPUs\n"
"    // This seems to give similiar performance as AppendStructuredBuffer\n"
"    // and can be also used with the GLSL shader\n"
"    uint numActive = WaveActiveCountBits(true);\n"
"    uint laneOffset = WavePrefixCountBits(true);\n"
"\n"
"    uint previousCount;\n"
"    // This is actually the first active lane\n"
"    if (WaveIsFirstLane())\n"
"        fragmentBufferCounter.InterlockedAdd(0, numActive, previousCount);\n"
"    previousCount = WaveReadLaneFirst(previousCount);\n"
"    uint newFragmentPosition = laneOffset + previousCount;\n"
"#else\n"
"    uint newFragmentPosition = 0;\n"
"    fragmentBufferCounter.InterlockedAdd(0, 1, newFragmentPosition);\n"
"#endif\n"
"    \n"
"    // Storing out of bounds values to head buffer may cause crash.\n"
"    if (newFragmentPosition < maxFragmentCount)\n"
"    {\n"
"        uint old_head_pointer;\n"
"        headPointerBuffer.InterlockedExchange(buffer_pointer * 4, newFragmentPosition,\n"
"            old_head_pointer);\n"
"\n"
"        fragment.nextPointer = old_head_pointer;\n"
"\n"
"        // Store final fragment\n"
"        fragmentBuffer[newFragmentPosition] = fragment;\n"
"    }\n"
"}\n"
"\n"
"bool IsListEnd(uint offset)\n"
"{\n"
"    uint endMarker = 0xFFFFFFFE;\n"
"    return offset >= endMarker;\n"
"}\n"
"\n"
"#define SINGLE_SIFT_DOWN_MIN(arr, n, swap, val)                \\\n"
"{                                                           \\\n"
"    int root = swap;                                        \\\n"
"    int child = root * 2 + 1;                               \\\n"
"    [flatten]                                               \\\n"
"    if (child < n && val.depth > arr[child].depth)                       \\\n"
"        swap = child;                                       \\\n"
"    [flatten]                                               \\\n"
"    if (child + 1 < n && val.depth > arr[child + 1].depth && arr[child].depth > arr[child+1].depth)             \\\n"
"        swap = child + 1;                                   \\\n"
"    arr[root]=arr[swap];                                    \\\n"
"}\n"
"\n"
"#define SINGLE_SIFT_DOWN_MAX(arr, swap, val)                \\\n"
"{                                                           \\\n"
"    int root = swap;                                        \\\n"
"    int child = root * 2 + 1;                               \\\n"
"    [flatten]                                               \\\n"
"    if (val.depth < arr[child].depth)                       \\\n"
"        swap = child;                                       \\\n"
"    [flatten]                                               \\\n"
"    if (val.depth < arr[child + 1].depth && arr[child].depth < arr[child+1].depth)             \\\n"
"        swap = child + 1;                                   \\\n"
"    arr[root]=arr[swap];                                    \\\n"
"}\n"
"\n"
"// TODO: This resolve function does not currently support half resolution fragments\n"
"/* Blends A-Buffer fragments over given background color */\n"
"void SortAndBlendABufferFragments(\n"
"    inout float3 backbufferColor, \n"
"    out float opaqueSurfaceVisibility, // inverse total alpha of the transparent layers\n"
"    uint2 texelPosition, uint targetWidth, \n"
"    StructuredBuffer<ABufferFragment> fragmentBuffer, \n"
"    Buffer<uint> headPointerBuffer,\n"
"    Buffer<uint> halfHeadPointerBuffer)\n"
"{\n"
"    opaqueSurfaceVisibility = 1.0;\n"
"\n"
"    // TODO: define must be moved somewhere else\n"
"    #define MAX_SIZE 7\n"
"    ABufferFragment fragments[MAX_SIZE];\n"
"    ABufferFragment fragment;\n"
"    int fragment_count = 0;\n"
"    \n"
"    uint head_index = texelPosition.x + texelPosition.y * targetWidth;\n"
"    uint halfHeadIndex = texelPosition.x / 2 + texelPosition.y * targetWidth / 4;\n"
"    uint headPointer = headPointerBuffer[head_index];\n"
"    uint halfHeadPointer = halfHeadPointerBuffer[halfHeadIndex];\n"
"    uint nextPointer = headPointer;\n"
" \n"
"    // Load to registers        \n"
"    while (!IsListEnd(nextPointer) && fragment_count < MAX_SIZE)\n"
"    {\n"
"        fragments[fragment_count] = fragmentBuffer[nextPointer];\n"
"    \n"
"        ++fragment_count;\n"
"            \n"
"        nextPointer = fragments[fragment_count].nextPointer;\n"
"    }\n"
"    \n"
"#if 1\n"
"    [branch]\n"
"    if (!IsListEnd(nextPointer))\n"
"    {\n"
"        // fetch more elements\n"
"        int swap;\n"
"        [unroll]\n"
"        for(int i = MAX_SIZE/2 - 1; i >= 0; i--)\n"
"        {\n"
"            swap = i;\n"
"            fragment = fragments[swap];\n"
"            SINGLE_SIFT_DOWN_MAX(fragments, swap, fragment);\n"
"            if(i < MAX_SIZE/4 && MAX_SIZE > 3)\n"
"                SINGLE_SIFT_DOWN_MAX(fragments, swap, fragment);\n"
"            if(i < MAX_SIZE/8 && MAX_SIZE > 7)\n"
"                SINGLE_SIFT_DOWN_MAX(fragments, swap, fragment);\n"
"            fragments[swap] = fragment;\n"
"        }\n"
"\n"
"        while (!IsListEnd(nextPointer))\n"
"        {\n"
"            fragment = fragmentBuffer[nextPointer];\n"
"            nextPointer = fragment.nextPointer;\n"
"           \n"
"            [branch]\n"
"            if (fragment.depth < fragments[0].depth)\n"
"            {\n"
"                swap = 0;\n"
"                SINGLE_SIFT_DOWN_MAX(fragments, swap, fragment);\n"
"#if MAX_SIZE > 3\n"
"                SINGLE_SIFT_DOWN_MAX(fragments, swap, fragment);\n"
"#endif\n"
"#if MAX_SIZE > 7\n"
"                SINGLE_SIFT_DOWN_MAX(fragments, swap, fragment);\n"
"#endif\n"
"                fragments[swap] = fragment;\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    [branch]\n"
"    if (fragment_count < 5) // we want the last branch to be at least half filled for heap to be better\n"
"    {\n"
"        int i = 0;\n"
"        \n"
"        // insertion sorting\n"
"        for (i = 1; i < fragment_count; i++)\n"
"        {\n"
"            fragment = fragments[i];\n"
"            int j;\n"
"            for (j = i; j > 0 && fragment.depth > fragments[j - 1].depth; j--)\n"
"            {\n"
"                fragments[j] = fragments[j - 1];\n"
"            }\n"
"\n"
"            fragments[j] = fragment;\n"
"        }\n"
"\n"
"        float3 color;\n"
"        float alpha;\n"
"       \n"
"        for (i = 0; i < fragment_count; ++i)\n"
"        {\n"
"            UnpackABufferFragment(fragments[i], color, alpha);\n"
"            // Data is assumed to be in premultiplied alpha-format,\n"
"            // so if alpha-blending, source color should be already multiplied\n"
"            // by alpha. If alpha = 0 and color > 0, this is basically additive blending.\n"
"            backbufferColor = backbufferColor*(1.0f - alpha) + color;\n"
"            opaqueSurfaceVisibility *= (1.0f - alpha);\n"
"        }\n"
"    }\n"
"    else\n"
"    {\n"
"        int i = 0;\n"
"        int swap;\n"
"        [unroll]\n"
"        for(i = MAX_SIZE/2 - 1; i >= 0; i--)\n"
"        {\n"
"            swap = i;\n"
"            fragment = fragments[swap];\n"
"            SINGLE_SIFT_DOWN_MIN(fragments, fragment_count, swap, fragment);\n"
"            if(i < MAX_SIZE/4 && MAX_SIZE > 3)\n"
"                SINGLE_SIFT_DOWN_MIN(fragments, fragment_count, swap, fragment);\n"
"            if(i < MAX_SIZE/8 && MAX_SIZE > 7)\n"
"                SINGLE_SIFT_DOWN_MIN(fragments, fragment_count, swap, fragment);\n"
"            fragments[swap] = fragment;\n"
"        }\n"
"\n"
"        float3 color;\n"
"        float alpha;\n"
"        float3 cumulativeColor = 0.f;\n"
"        float cumulativeAlpha = 1.f;\n"
"        \n"
"        for (i = fragment_count; i > MAX_SIZE/2 && cumulativeAlpha > .5f; i--)\n"
"        {\n"
"            UnpackABufferFragment(fragments[0], color, alpha);\n"
"            cumulativeColor += color*cumulativeAlpha;\n"
"            cumulativeAlpha *= 1.f - alpha;\n"
"\n"
"            fragment = fragments[i - 1];\n"
"            swap = 0;\n"
"            SINGLE_SIFT_DOWN_MIN(fragments, i, swap, fragment);\n"
"#if MAX_SIZE > 3\n"
"            SINGLE_SIFT_DOWN_MIN(fragments, i, swap, fragment);\n"
"#endif\n"
"#if MAX_SIZE > 7\n"
"            SINGLE_SIFT_DOWN_MIN(fragments, i, swap, fragment);\n"
"#endif\n"
"            fragments[swap] = fragment;\n"
"        }\n"
"\n"
"#if MAX_SIZE > 3\n"
"        for (; i > MAX_SIZE/4 && cumulativeAlpha > .5f; i--)\n"
"        {\n"
"            UnpackABufferFragment(fragments[0], color, alpha);\n"
"            cumulativeColor += color*cumulativeAlpha;\n"
"            cumulativeAlpha *= 1.f - alpha;\n"
"\n"
"            fragment = fragments[i - 1];\n"
"            swap = 0;\n"
"            SINGLE_SIFT_DOWN_MIN(fragments, i, swap, fragment);\n"
"#if MAX_SIZE > 7\n"
"            SINGLE_SIFT_DOWN_MIN(fragments, i, swap, fragment);\n"
"#endif\n"
"            fragments[swap] = fragment;\n"
"        }\n"
"#endif\n"
"        \n"
"#if MAX_SIZE > 7\n"
"        for (; i > MAX_SIZE/8 && cumulativeAlpha > .5f; i--)\n"
"        {\n"
"            UnpackABufferFragment(fragments[0], color, alpha);\n"
"            cumulativeColor += color*cumulativeAlpha;\n"
"            cumulativeAlpha *= 1.f - alpha;\n"
"\n"
"            fragment = fragments[i - 1];\n"
"            swap = 0;\n"
"            SINGLE_SIFT_DOWN_MIN(fragments, i, swap, fragment);\n"
"            fragments[swap] = fragment;\n"
"        }\n"
"#endif\n"
"\n"
"        for (int j = 0; j < i; j++)\n"
"        {\n"
"            UnpackABufferFragment(fragments[j], color, alpha);\n"
"            cumulativeColor += color*cumulativeAlpha;\n"
"            cumulativeAlpha *= 1.f - alpha;\n"
"        }\n"
"\n"
"        backbufferColor = cumulativeColor + cumulativeAlpha*backbufferColor;\n"
"        opaqueSurfaceVisibility = cumulativeAlpha;\n"
"    }\n"
"    \n"
"#else\n"
"    // Insertion sort (for back to front blending)\n"
"    // NOTE: this could be optimized if we know that objects are\n"
"    // draw back to front and they only contain maximum of N\n"
"    // number of overlapping surfaces. Could sort then only closest\n"
"    // N.\n"
"    for (i = 1; i < fragment_count; i++)\n"
"    {\n"
"        fragment = fragments[i];\n"
"        int j;\n"
"        for (j = i; j > 0 && fragment.depth > fragments[j-1].depth; j--)\n"
"        {\n"
"            fragments[j] = fragments[j - 1];\n"
"        }\n"
"\n"
"        fragments[j] = fragment;\n"
"    }\n"
"\n"
"    // load the rest (while keeping the order)\n"
"    while (pointer != (uint)0xFFFFFFFF)\n"
"    {\n"
"        fragment = fragmentBuffer[pointer];\n"
"        pointer = fragment.nextPointer;\n"
"        [branch]\n"
"        if (fragment.depth < fragments[0].depth)\n"
"        {\n"
"            for (i = 0; i < MAX_SIZE - 1 && fragment.depth < fragments[i + 1].depth; i++)\n"
"                fragments[i] = fragments[i + 1];\n"
"            fragments[i] = fragment;\n"
"        }\n"
"    }\n"
"    \n"
"    float3 color;\n"
"    float alpha;\n"
"    \n"
"#if 1\n"
"    \n"
"    // Apply\n"
"    for(i = 0; i < fragment_count; ++i)\n"
"    {\n"
"        UnpackABufferFragment(fragments[i], color, alpha);\n"
"        // Data is assumed to be in premultiplied alpha-format,\n"
"        // so if alpha-blending, source color should be already multiplied\n"
"        // by alpha. If alpha = 0 and color > 0, this is basically additive blending.\n"
"        backbufferColor = backbufferColor*(1.0f - alpha) + color;\n"
"        opaqueSurfaceVisibility *= (1.0f - alpha);\n"
"    }\n"
"    \n"
"#else\n"
"    float3 cumulativeColor = 0.f;\n"
"    float cumulativeAlpha = 1.f;\n"
"    \n"
"    // front to back\n"
"    // can clamp early, if cumulativeAlpha < epsilon\n"
"    for (i = fragment_count - 1; i >= 0; i--)\n"
"    {\n"
"        UnpackABufferFragment(fragments[i], color, alpha);\n"
"        cumulativeColor += color*cumulativeAlpha;\n"
"        cumulativeAlpha *= 1.f - alpha;\n"
"    }\n"
"    \n"
"    backbufferColor = cumulativeColor + cumulativeAlpha*backbufferColor;\n"
"    opaqueSurfaceVisibility = cumulativeAlpha;\n"
"#endif\n"
"\n"
"#endif\n"
"}\n"
"\n"
"\n"
"\n"
"// Adaptive Transparency\n"
"// Marco Salvi, Jefferson Montgomery, Aaron Lefohn\n"
"\n"
"#define AOIT_NODE_COUNT 8\n"
"#define AOIT_FIRT_NODE_TRANS    (1)\n"
"#define AOIT_RT_COUNT           (AOIT_NODE_COUNT / 4)\n"
"#define AIOT_EMPTY_NODE_DEPTH   (1E30)\n"
"#define AOIT_DONT_COMPRESS_FIRST_HALF\n"
"\n"
"struct AOITData\n"
"{\n"
"    float4 depth[AOIT_RT_COUNT];\n"
"    float4 trans[AOIT_RT_COUNT];\n"
"};\n"
"\n"
"struct AOITFragment\n"
"{\n"
"    int   index;\n"
"    float depthA;\n"
"    float transA;\n"
"};\n"
"\n"
"AOITFragment AOITFindFragment(in AOITData data, in float fragmentDepth)\n"
"{\n"
"    int    index;\n"
"    float4 depth, trans;\n"
"    float  leftDepth;\n"
"    float  leftTrans;\n"
"    \n"
"    AOITFragment Output;\n"
"\n"
"#if AOIT_RT_COUNT > 3\n"
"    [flatten]if (fragmentDepth > data.depth[2][3])\n"
"    {\n"
"        depth        = data.depth[3];\n"
"        trans        = data.trans[3];\n"
"        leftDepth    = data.depth[2][3];\n"
"        leftTrans    = data.trans[2][3];    \n"
"        Output.index = 12;        \n"
"    }\n"
"    else\n"
"#endif\n"
"#if AOIT_RT_COUNT > 2\n"
"    [flatten]if (fragmentDepth > data.depth[1][3])\n"
"    {\n"
"        depth        = data.depth[2];\n"
"        trans        = data.trans[2];\n"
"        leftDepth    = data.depth[1][3];\n"
"        leftTrans    = data.trans[1][3];          \n"
"        Output.index = 8;        \n"
"    }\n"
"    else\n"
"#endif\n"
"#if AOIT_RT_COUNT > 1\n"
"    [flatten]if (fragmentDepth > data.depth[0][3])\n"
"    {\n"
"        depth        = data.depth[1];\n"
"        trans        = data.trans[1];\n"
"        leftDepth    = data.depth[0][3];\n"
"        leftTrans    = data.trans[0][3];       \n"
"        Output.index = 4;        \n"
"    }\n"
"    else\n"
"#endif\n"
"    {    \n"
"        depth        = data.depth[0];\n"
"        trans        = data.trans[0];\n"
"        leftDepth    = data.depth[0][0];\n"
"        leftTrans    = data.trans[0][0];      \n"
"        Output.index = 0;        \n"
"    } \n"
"      \n"
"    [flatten]if (fragmentDepth <= depth[0])\n"
"    {\n"
"        Output.depthA = leftDepth;\n"
"        Output.transA = leftTrans;\n"
"    }\n"
"    else if (fragmentDepth <= depth[1])\n"
"    {\n"
"        Output.index += 1;\n"
"        Output.depthA = depth[0]; \n"
"        Output.transA = trans[0];            \n"
"    }\n"
"    else if (fragmentDepth <= depth[2])\n"
"    {\n"
"        Output.index += 2;\n"
"        Output.depthA = depth[1];\n"
"        Output.transA = trans[1];            \n"
"    }\n"
"    else if (fragmentDepth <= depth[3])\n"
"    {\n"
"        Output.index += 3;    \n"
"        Output.depthA = depth[2];\n"
"        Output.transA = trans[2];            \n"
"    }\n"
"    else\n"
"    {\n"
"        Output.index += 4;       \n"
"        Output.depthA = depth[3];\n"
"        Output.transA = trans[3];         \n"
"    }\n"
"    \n"
"    return Output;\n"
"}\n"
"\n"
"void AOITInsertFragment(in float fragmentDepth,\n"
"                        in float fragmentTrans,\n"
"                        inout AOITData AOITData)\n"
"{   \n"
"    int i, j;\n"
"  \n"
"    // Unpack AOIT data\n"
"    float depth[AOIT_NODE_COUNT + 1];\n"
"    float trans[AOIT_NODE_COUNT + 1];\n"
"    [unroll] for (i = 0; i < AOIT_RT_COUNT; ++i)\n"
"        [unroll] for (j = 0; j < 4; ++j)\n"
"        {\n"
"            depth[4 * i + j] = AOITData.depth[i][j];\n"
"            trans[4 * i + j] = AOITData.trans[i][j];\n"
"        }\n"
"\n"
"    // Find insertion index \n"
"    AOITFragment tempFragment = AOITFindFragment(AOITData, fragmentDepth);\n"
"    const int   index = tempFragment.index;\n"
"    // If we are inserting in the first node then use 1.0 as previous transmittance value\n"
"    // (we don't store it, but it's implicitly set to 1. This allows us to store one more node)\n"
"    const float prevTrans = index != 0 ? tempFragment.transA : 1.0f;\n"
"\n"
"    // Make space for the new fragment. Also composite new fragment with the current curve \n"
"    // (except for the node that represents the new fragment)\n"
"    [unroll]for (i = AOIT_NODE_COUNT - 1; i >= 0; --i)\n"
"        [flatten]if (index <= i)\n"
"        {\n"
"            depth[i + 1] = depth[i];\n"
"            trans[i + 1] = trans[i] * fragmentTrans;\n"
"        }\n"
"    \n"
"    // Insert new fragment\n"
"    [unroll]for (i = 0; i <= AOIT_NODE_COUNT; ++i)\n"
"        [flatten]if (index == i)\n"
"        {\n"
"            depth[i] = fragmentDepth;\n"
"            trans[i] = fragmentTrans * prevTrans;\n"
"        }\n"
"\n"
"    const int removalCandidateCount = (AOIT_NODE_COUNT + 1) - 1;\n"
"\n"
"#ifdef AOIT_DONT_COMPRESS_FIRST_HALF\n"
"    // Although to bias our compression scheme in order to favor..\n"
"    // .. the closest nodes to the eye we skip the first 50%\n"
"    const int startRemovalIdx = removalCandidateCount / 2;\n"
"#else\n"
"    const int startRemovalIdx = 1;\n"
"#endif\n"
"\n"
"    float nodeUnderError[removalCandidateCount];\n"
"        \n"
"    // pack representation if we have too many nodes\n"
"    [flatten]if (depth[AOIT_NODE_COUNT] != AIOT_EMPTY_NODE_DEPTH)\n"
"    {\n"
"        // That's total number of nodes that can be possibly removed\n"
"        [unroll]for (i = startRemovalIdx; i < removalCandidateCount; ++i)\n"
"            nodeUnderError[i] = (depth[i] - depth[i - 1]) * (trans[i - 1] - trans[i]);\n"
"\n"
"        // Find the node the generates the smallest removal error\n"
"        int smallestErrorIdx;\n"
"        float smallestError;\n"
"\n"
"        smallestErrorIdx = startRemovalIdx;\n"
"        smallestError    = nodeUnderError[smallestErrorIdx];\n"
"        i = startRemovalIdx + 1;\n"
"\n"
"        [unroll]for ( ; i < removalCandidateCount; ++i)\n"
"            [flatten]if (nodeUnderError[i] < smallestError)\n"
"            {\n"
"                smallestError = nodeUnderError[i];\n"
"                smallestErrorIdx = i;\n"
"            }\n"
"\n"
"        // Remove that node..\n"
"        [unroll]for (i = startRemovalIdx; i < AOIT_NODE_COUNT; ++i)\n"
"            [flatten]if (smallestErrorIdx <= i)\n"
"                depth[i] = depth[i + 1];\n"
"        [unroll]for (i = startRemovalIdx - 1; i < AOIT_NODE_COUNT; ++i)\n"
"            [flatten]if (smallestErrorIdx - 1 <= i)\n"
"                trans[i] = trans[i + 1];\n"
"    }\n"
"    \n"
"    // Pack AOIT data\n"
"    [unroll] for (i = 0; i < AOIT_RT_COUNT; ++i)\n"
"        [unroll] for (j = 0; j < 4; ++j)\n"
"        {\n"
"            AOITData.depth[i][j] = depth[4 * i + j];\n"
"            AOITData.trans[i][j] = trans[4 * i + j];\n"
"        }\n"
"}\n"
"\n"
"void AddFragmentsToVisibilityFunction(\n"
"    inout AOITData data, \n"
"    StructuredBuffer<ABufferFragment> fragmentBuffer, \n"
"    uint nodeOffset, \n"
"    float filteringWeight)\n"
"{\n"
"    [loop] while (!IsListEnd(nodeOffset))\n"
"    {\n"
"        // Get node..\n"
"        ABufferFragment node = fragmentBuffer[nodeOffset];\n"
"\n"
"        // Unpack color\n"
"        float3 nodeColor;\n"
"        float nodeAlpha;\n"
"    \n"
"        UnpackABufferFragment(node, nodeColor, nodeAlpha);\n"
"        nodeAlpha *= filteringWeight;\n"
"        AOITInsertFragment(node.depth,  saturate(1.0f - nodeAlpha), data);\n"
"\n"
"        nodeOffset = node.nextPointer;\n"
"    }\n"
"}\n"
"\n"
"void ApproximateVisibilityAndBlendABufferFragments(\n"
"    inout float3 backbufferColor,\n"
"    out float opaqueSurfaceVisibility, // inverse total alpha of the transparent layers\n"
"    uint2 texelPosition, \n"
"    uint2 targetSize, \n"
"    StructuredBuffer<ABufferFragment> fragmentBuffer, \n"
"    Buffer<uint> headPointerBufferLod0,\n"
"    Buffer<uint> headPointerBufferLod1\n"
"    )\n"
"{\n"
"    uint lod0HeadIndex = texelPosition.x + texelPosition.y * targetSize.x;\n"
"    uint lod0HeadOffset = headPointerBufferLod0[lod0HeadIndex];\n"
"    \n"
"    int2 lod1TargetSize = targetSize / 2;\n"
"    \n"
"    uint2 lod1Texel = texelPosition / 2;\n"
"    uint lod1HeadIndex = lod1Texel.x + lod1Texel.y * lod1TargetSize.x;    \n"
"    uint lod1HeadOffset = headPointerBufferLod1[lod1HeadIndex];\n"
"\n"
"    AOITData data;\n"
"    // Initialize AVSM data\n"
"    [unroll]for (int i = 0; i < AOIT_RT_COUNT; ++i)\n"
"    {\n"
"        data.depth[i] = AIOT_EMPTY_NODE_DEPTH.xxxx;\n"
"        data.trans[i] = AOIT_FIRT_NODE_TRANS.xxxx;\n"
"    }\n"
"\n"
"    uint firstOffset = lod0HeadOffset == 0xFFFFFFFE ? lod1HeadOffset : lod0HeadOffset; \n"
"    uint nodeOffset = firstOffset;\n"
"    [loop] while (!IsListEnd(nodeOffset))\n"
"    {\n"
"        // Get node..\n"
"        ABufferFragment node = fragmentBuffer[nodeOffset];\n"
"\n"
"        // Unpack color\n"
"        float3 nodeColor;\n"
"        float nodeAlpha;\n"
"    \n"
"        UnpackABufferFragment(node, nodeColor, nodeAlpha);          \n"
"        AOITInsertFragment(node.depth,  saturate(1.0f - nodeAlpha), data);\n"
"\n"
"        nodeOffset = node.nextPointer == 0xFFFFFFFE ? lod1HeadOffset : node.nextPointer;\n"
"    }\n"
"\n"
"    backbufferColor *= data.trans[AOIT_RT_COUNT - 1][3];\n"
"    opaqueSurfaceVisibility = data.trans[AOIT_RT_COUNT - 1][3];\n"
"    \n"
"    nodeOffset = firstOffset;\n"
"    [loop] while (!IsListEnd(nodeOffset))\n"
"    {\n"
"        // Get node..\n"
"        ABufferFragment node = fragmentBuffer[nodeOffset];\n"
"\n"
"        // Unpack color\n"
"        float3 nodeColor;\n"
"        float nodeAlpha;\n"
"    \n"
"        UnpackABufferFragment(node, nodeColor, nodeAlpha);\n"
"        AOITFragment frag = AOITFindFragment(data, node.depth);\n"
"    \n"
"        float vis = frag.index == 0 ? 1.0f : frag.transA;\n"
"        backbufferColor += nodeColor * vis;\n"
"\n"
"        nodeOffset = node.nextPointer == 0xFFFFFFFE ? lod1HeadOffset : node.nextPointer;\n"
"    }\n"
"}\n"
"#line 2 \"material_surface_shading.hlsl\"\n"
"#ifndef EVA_GEOMETRY_MATERIAL_SURFACE_SHADING_HLSL\n"
"#define EVA_GEOMETRY_MATERIAL_SURFACE_SHADING_HLSL\n"
"\n"
"// TODO: move these to common shader library\n"
"// These are here so that they can be accessed by both\n"
"// surface shading and transparent surface shading.\n"
"float2 UnpackUNorm8ToSNorm8(float2 unorm8)\n"
"{\n"
"    float2 unsignedUnnormalized = unorm8 * 255;\n"
"    float2 signedUnormalized = unsignedUnnormalized - 128;\n"
"    float2 signedNormalized = signedUnormalized / 127;\n"
"    return max(-1, signedNormalized);\n"
"}\n"
"\n"
"float3 UnpackNormal(Texture2D<float2> normalTexture, SamplerState sam, float2 texCoord)\n"
"{\n"
"    float2 xy = UnpackUNorm8ToSNorm8(normalTexture.Sample(sam, texCoord));\n"
"    return float3(xy, sqrt(1.0 - clamp(dot(xy, xy), 0.0, 1.0)));\n"
"}\n"
"\n"
"#if defined(EVA_SURFACE_SHADING)\n"
"\n"
"// Inputs:\n"
"// float2 TexCoord : TexCoord;\n"
"// float3 EyeDirectionInView : EyeDirectionInView;\n"
"// float3 TangentInView : TangentInView;\n"
"// float3 BitangentInView : BitangentInView;\n"
"// float3 NormalInView : NormalInView;\n"
"// float3 EyeDirectionInWorld : EyeDirectionInWorld\n"
"//\n"
"// Outputs:\n"
"// float3 Normal : SV_Target0;\n"
"// float4 Albedo : SV_Target1;\n"
"// float3 Attribute : SV_Target2;\n"
"//\n"
"// Constants:\n"
"// See MaterialConstants in materials.xml \n"
"//\n"
"// Notes:\n"
"// input coverage is provided from ApplyAlphaTestClipping function.\n"
"//\n"
"\n"
"DM_GFX_VK_BINDING(1, 3)\n"
"Texture2D<float4> DiffuseTexture : register(EVA_REGISTER_SRV_MATERIAL_DIFFUSE);\n"
"DM_GFX_VK_BINDING(2, 3)\n"
"Texture2D<float2> AttributeTexture : register(EVA_REGISTER_SRV_MATERIAL_SURFACE_ATTRIBUTES);\n"
"DM_GFX_VK_BINDING(3, 3)\n"
"Texture2D<float2> NormalTexture : register(EVA_REGISTER_SRV_MATERIAL_NORMAL);\n"
"DM_GFX_VK_BINDING(4, 3)\n"
"Texture2D<float> AmbientOcclusionTexture : register(EVA_REGISTER_SRV_MATERIAL_AMBIENT_OCCLUSION);\n"
"\n"
"#ifdef EVA_TEXTURE_DETAIL\n"
"DM_GFX_VK_BINDING(7, 3)\n"
"Texture2D<float3> NormalAndDiffuseDetailTexture : register(EVA_REGISTER_SRV_MATERIAL_NORMAL_AND_DIFFUSE_DETAIL);\n"
"#endif\n"
"\n"
"#ifdef EVA_TEXTURE_BLENDING\n"
"DM_GFX_VK_BINDING(8, 3)\n"
"Texture2D<float4> DiffuseTexture1 : register(EVA_REGISTER_SRV_MATERIAL_DIFFUSE1);\n"
"DM_GFX_VK_BINDING(9, 3)\n"
"Texture2D<float2> NormalTexture1 : register(EVA_REGISTER_SRV_MATERIAL_NORMAL1);\n"
"DM_GFX_VK_BINDING(11, 3)\n"
"Texture2D<float3> NormalAndDiffuseDetailTexture1 : register(EVA_REGISTER_SRV_MATERIAL_NORMAL_AND_DIFFUSE_DETAIL1);\n"
"#endif\n"
"\n"
"#ifdef EVA_RGBA_BLEND\n"
"DM_GFX_VK_BINDING(13, 3)\n"
"Texture2D<float4> BlendMap : register(EVA_REGISTER_SRV_MATERIAL_RGBA_BLEND_MAP);\n"
"DM_GFX_VK_BINDING(14, 3)\n"
"Texture2D<float4> DiffuseTextures[EVA_RGBA_BLEND_MAX_CHANNEL_COUNT] : register(EVA_REGISTER_SRV_MATERIAL_RGBA_DIFFUSE_TEXTURES);\n"
"DM_GFX_VK_BINDING(18, 3)\n"
"Texture2D<float2> AttributeTextures[EVA_RGBA_BLEND_MAX_CHANNEL_COUNT] : register(EVA_REGISTER_SRV_MATERIAL_RGBA_ATTRIBUTE_TEXTURES);\n"
"DM_GFX_VK_BINDING(22, 3)\n"
"Texture2D<float2> NormalTextures[EVA_RGBA_BLEND_MAX_CHANNEL_COUNT] : register(EVA_REGISTER_SRV_MATERIAL_RGBA_NORMAL_TEXTURES);\n"
"#endif // EVA_RGBA_BLEND\n"
"\n"
"\n"
"float4 Material_Diffuse_and_Metalness(PixelInput input, float2 texCoord, float detailFade, float4 blendWeights, float4x2 blendChannelTextureCoordinates)\n"
"{\n"
"    float4 sampleVar = DiffuseTexture.Sample(SurfaceSampler, texCoord);\n"
"    \n"
"#ifdef EVA_TEXTURE_BLENDING\n"
"    float3 diffuse0 = sampleVar.xyz;\n"
"    float3 diffuse1 = DiffuseTexture1.Sample(SurfaceSampler, input.TexCoords.zw).xyz;\n"
"    sampleVar.xyz = input.Color_BlendFactor.xyz * lerp(diffuse0, diffuse1, input.Color_BlendFactor.w);\n"
"#endif\n"
"\n"
"    // Multiply base material sample with diffuse color before RGBA blend and \n"
"    // other additional material properties, which should not be affected.\n"
"    sampleVar.xyz *= DiffuseColor;\n"
"\n"
"#ifdef EVA_RGBA_BLEND\n"
"    // Color overwrites always the material color below it\n"
"    [unroll] for (int i = 0; i < EVA_RGBA_BLEND_CHANNEL_COUNT; ++i)\n"
"        sampleVar = lerp(sampleVar, DiffuseTextures[i].Sample(SurfaceSampler, blendChannelTextureCoordinates[i]) * float4(RgbaBlendDiffuseColor_UVTileMultiplier[i].xyz, 1.f), blendWeights[i]);\n"
"#endif\n"
"\n"
"#ifdef EVA_TEXTURE_DETAIL\n"
"#ifdef EVA_TEXTURE_BLENDING\n"
"    float3 normalAndDiffuse0 = NormalAndDiffuseDetailTexture.Sample(SurfaceSampler, texCoord * DiffuseAndNormalWeightsAndTiling.z);\n"
"    float3 normalAndDiffuse1 = NormalAndDiffuseDetailTexture1.Sample(SurfaceSampler, input.TexCoords.zw * DiffuseAndNormalWeightsAndTiling.z);\n"
"    float3 normalAndDiffuse = lerp(normalAndDiffuse0, normalAndDiffuse1, input.Color_BlendFactor.w);\n"
"#else\n"
"    float3 normalAndDiffuse = NormalAndDiffuseDetailTexture.Sample(SurfaceSampler, texCoord * DiffuseAndNormalWeightsAndTiling.z);\n"
"#endif\n"
"    sampleVar = lerp(sampleVar, sampleVar * normalAndDiffuse.z, DiffuseAndNormalWeightsAndTiling.x * detailFade);\n"
"#endif\n"
"\n"
"    return sampleVar;\n"
"}\n"
"\n"
"float2 Material_Attributes(float2 texCoord, float4 blendWeights, float4x2 blendChannelTextureCoordinates)\n"
"{\n"
"    float2 sampleVar = AttributeTexture.Sample(SurfaceSampler, texCoord);\n"
"\n"
"#ifdef EVA_RGBA_BLEND\n"
"    int i = 0;\n"
"    // Overwrite mode; combine attributes based on weight\n"
"    [unroll] for (; i < EVA_RGBA_BLEND_LERP_NORMALS_COUNT; ++i) {\n"
"        sampleVar = lerp(sampleVar, AttributeTextures[i].Sample(SurfaceSampler, blendChannelTextureCoordinates[i]), blendWeights[i]);\n"
"    }\n"
"\n"
"#if EVA_RGBA_BLEND_LERP_NORMALS_COUNT != EVA_RGBA_BLEND_CHANNEL_COUNT\n"
"    // Overpaint mode: base cavity multiplied by total paint cavity, roughess lerped\n"
"    // TODO: can this be optimized without detoriorating blend quality?\n"
"    float total_cavity = 0.f;\n"
"    float total_blendweights = 0.f;\n"
"     for (; i < EVA_RGBA_BLEND_CHANNEL_COUNT; ++i) {\n"
"        float2 attributes = AttributeTextures[i].Sample(SurfaceSampler, blendChannelTextureCoordinates[i]);\n"
"        total_blendweights += blendWeights[i];\n"
"        total_cavity += attributes.g * blendWeights[i];\n"
"        sampleVar.x = lerp(sampleVar.x, attributes.x, blendWeights[i]);\n"
"    }\n"
"\n"
"    // If sum(blendWeights) = 1, total cavity is \"base cavity * (weighted sum of layered cavities)\".\n"
"    // However, many times blendweights don't sum to 1 (eg. if layers have \"holes\", which means\n"
"    // that base material should show trough). Mixing 1.f (no cavity) with the total cavity\n"
"    // produces the correct visual result.\n"
"    sampleVar.y *= lerp(1.f, total_cavity, min(1.f, total_blendweights));\n"
"#endif\n"
"#endif\n"
"\n"
"    return sampleVar;\n"
"}\n"
"\n"
"float3 Material_NormalInWorld(float3 normalInView)\n"
"{\n"
"    // No scaling allowed in camera matrix\n"
"    return mul((float3x3)ViewConstants.ViewToWorldMatrix, normalInView);\n"
"}\n"
"\n"
"// \"Unity normal blending\"; from http://blog.selfshadow.com/publications/blending-in-detail/\n"
"// Transforms detail normal (n2) into tangent space of n1\n"
"float3 BlendNormals(float3 n1, float3 n2, float weight)\n"
"{\n"
"    n2 = normalize(float3(n2.xy*weight, n2.z));\n"
"\n"
"    float3 r;\n"
"    r.x = dot(n1.zxx, n2.xyz);\n"
"    r.y = dot(n1.yzy, n2.xyz);\n"
"    r.z = dot(float3(-n1.xy, n1.z), n2.xyz);\n"
"    return normalize(r);\n"
"}\n"
"\n"
"//#define EVA_PS_TANGENTS\n"
"\n"
"// Returns surface normal in view space.\n"
"float3 Material_NormalInView(PixelInput input, float2 texCoord, float detailFade, float4 blendWeights, float4x2 blendChannelTextureCoordinates)\n"
"{\n"
"#ifdef EVA_TEXTURE_BLENDING\n"
"    float3 normalInTangent0 = UnpackNormal(NormalTexture, SurfaceSampler, input.TexCoords.xy);\n"
"    float3 normalInTangent1 = UnpackNormal(NormalTexture1, SurfaceSampler, input.TexCoords.zw);\n"
"    float3 normalInTangent = lerp(normalInTangent0, normalInTangent1, input.Color_BlendFactor.w);\n"
"#else\n"
"    float3 normalInTangent = UnpackNormal(NormalTexture, SurfaceSampler, texCoord);\n"
"#endif\n"
"        \n"
"#ifdef EVA_RGBA_BLEND\n"
"    int i = 0;\n"
"    [unroll] for (; i < EVA_RGBA_BLEND_LERP_NORMALS_COUNT; ++i) {\n"
"        normalInTangent = lerp(normalInTangent, UnpackNormal(NormalTextures[i], SurfaceSampler, blendChannelTextureCoordinates[i]), blendWeights[i]);\n"
"    }\n"
"\n"
"    // rest of the normals are blended in detail mode\n"
"   for (; i < EVA_RGBA_BLEND_CHANNEL_COUNT; ++i) {\n"
"        normalInTangent = BlendNormals(normalInTangent, UnpackNormal(NormalTextures[i], SurfaceSampler, blendChannelTextureCoordinates[i]), blendWeights[i]);\n"
"    }\n"
"#endif\n"
"\n"
"#ifdef EVA_TEXTURE_DETAIL\n"
"#ifdef EVA_TEXTURE_BLENDING\n"
"    float2 dxy0 = UnpackUNorm8ToSNorm8(\n"
"        NormalAndDiffuseDetailTexture.Sample(SurfaceSampler, input.TexCoords.xy * DiffuseAndNormalWeightsAndTiling.w).xy);\n"
"    float2 dxy1 = UnpackUNorm8ToSNorm8(\n"
"        NormalAndDiffuseDetailTexture1.Sample(SurfaceSampler, input.TexCoords.zw * DiffuseAndNormalWeightsAndTiling.w).xy);\n"
"    float3 detailNormal0 = float3(dxy0, sqrt(1 - clamp(dot(dxy0, dxy0), 0.0, 1.0)));\n"
"    float3 detailNormal1 = float3(dxy1, sqrt(1 - clamp(dot(dxy1, dxy1), 0.0, 1.0)));\n"
"    float3 detailNormal = normalize(lerp(detailNormal0, detailNormal1, input.Color_BlendFactor.w));\n"
"#else\n"
"    float2 dxy = UnpackUNorm8ToSNorm8(\n"
"        NormalAndDiffuseDetailTexture.Sample(SurfaceSampler, texCoord * DiffuseAndNormalWeightsAndTiling.w).xy);\n"
"        \n"
"    float3 detailNormal = float3(dxy, sqrt(1 - clamp(dot(dxy, dxy), 0.0, 1.0)));\n"
"#endif\n"
"    normalInTangent = BlendNormals(normalInTangent, detailNormal, DiffuseAndNormalWeightsAndTiling.y * detailFade);\n"
"#endif\n"
"\n"
"#ifndef EVA_PS_TANGENTS\n"
"    float3x3 tangentToViewMatrix = float3x3(\n"
"        normalize(input.TangentInView),\n"
"        normalize(input.BitangentInView),\n"
"        normalize(input.NormalInView));\n"
"        \n"
"    float3 normalInView = mul(normalInTangent, tangentToViewMatrix);\n"
"#else\n"
"    // texture coordinates are (s,t)\n"
"    // screen coordinates are (x,y)\n"
"    float2 dst_dx = ddx(texCoord.xy);\n"
"    float2 dst_dy = ddy(texCoord.xy);\n"
"    float3 dS_dx = ddx(input.Position.xyz);\n"
"    float3 dS_dy = ddy(input.Position.xyz);\n"
"    \n"
"    float det = dst_dx.x*dst_dy.y - dst_dx.y*dst_dy.x;\n"
"    float invDet = 1.f/det;\n"
"    // we don't really need to divide by det, vectors are normalized anyway\n"
"    float2 dxy_ds = float2(dst_dy.y, -dst_dy.x) * invDet;\n"
"    float2 dxy_dt = float2(-dst_dx.y, dst_dx.x) * invDet;\n"
"    \n"
"    float3 dS_ds = dS_dx * dxy_ds.x + dS_dy * dxy_ds.y;\n"
"    float3 dS_dt = dS_dx * dxy_dt.x + dS_dy * dxy_dt.y;\n"
"    float3 n = normalize(input.NormalInView);\n"
"    dS_ds -= n * dot(dS_ds, n);\n"
"    dS_dt -= n * dot(dS_dt, n);\n"
"    if(dot(cross(dS_ds, dS_dt), n) < 0)\n"
"    {\n"
"        //dS_dt = cross(n, dS_ds);\n"
"        //dS_dt = -dS_dt;\n"
"        //dS_dt = reflect(-dS_dt, normalize(dS_ds));\n"
"        //dS_ds = -dS_ds;\n"
"        //dS_ds = reflect(-dS_ds, normalize(dS_dt));\n"
"        float3 tmp = dS_ds;\n"
"        dS_ds = -dS_dt;\n"
"        dS_dt = -tmp;\n"
"    }\n"
"#if 1\n"
"    float3 normalInView = det == 0.f ? n : (n * normalInTangent.z\n"
"                        + normalize(cross(n, dS_ds)) * normalInTangent.y\n"
"                        + normalize(cross(dS_dt, n)) * normalInTangent.x);\n"
"#else\n"
"    normalInTangent /= max(normalInTangent.z, 1e-6f);\n"
"    float3 normalInView = det == 0.f ? n : (cross(dS_ds, dS_dt)\n"
"                        + cross(n, dS_ds) * normalInTangent.y\n"
"                        + cross(dS_dt, n) * normalInTangent.x);\n"
"#endif\n"
"#endif\n"
"\n"
"#ifdef EVA_DOUBLE_SIDED_SURFACE_SHADING\n"
"    normalInView = input.IsFrontFace ? normalInView : -normalInView;\n"
"#endif\n"
"    return normalize(normalInView);\n"
"}\n"
"\n"
"float Luminance__(float3 rgb)\n"
"{\n"
"    float3 luminance_weights = float3(0.2126, 0.7152, 0.0722);\n"
"    return dot(luminance_weights, rgb);\n"
"}\n"
"\n"
"void ApplySurfaceShading(\n"
"    PixelInput input,\n"
"    uint coverage,\n"
"    inout PixelOutput output,\n"
"    out float3 normalInView)\n"
"{\n"
"#ifdef EVA_TEXTURE_DETAIL\n"
"    float detailFade = saturate(1.0 - (length(input.EyeDirectionInView) - FadeOutStartAndLength.x) / FadeOutStartAndLength.y);\n"
"#else\n"
"    float detailFade = 1;\n"
"#endif\n"
"\n"
"    float2 texCoord;\n"
"\n"
"#if defined(EVA_RGBA_BLEND_EXTRA_UVS) || defined(EVA_TEXTURE_BLENDING)\n"
"    texCoord = input.TexCoords.xy;\n"
"#else\n"
"    texCoord = input.TexCoord;\n"
"#endif\n"
"\n"
"#ifdef EVA_RGBA_BLEND\n"
"    float2 blendTextureCoordinateInput;\n"
"\n"
"    #ifdef EVA_RGBA_BLEND_EXTRA_UVS \n"
"        blendTextureCoordinateInput = input.TexCoords.zw; \n"
"    #else\n"
"        blendTextureCoordinateInput = input.TexCoord.xy;\n"
"    #endif\n"
"\n"
"    float4 blendWeights = BlendMap.Sample(SurfaceSampler, blendTextureCoordinateInput);\n"
"    float4x2 blendChannelTextureCoordinates;\n"
"\n"
"    [unroll] for (int i = 0; i < EVA_RGBA_BLEND_CHANNEL_COUNT; ++i)\n"
"        blendChannelTextureCoordinates[i] = blendTextureCoordinateInput * RgbaBlendDiffuseColor_UVTileMultiplier[i].w + RgbaBlendUVOffset[i].xy;\n"
"#else\n"
"    float4 blendWeights = (float4)0.;\n"
"    float4x2 blendChannelTextureCoordinates = (float4x2)0.;\n"
"#endif\n"
"\n"
"    normalInView = Material_NormalInView(input, texCoord, detailFade, blendWeights, blendChannelTextureCoordinates);\n"
" \n"
"    float4 albedo = Material_Diffuse_and_Metalness(input, texCoord, detailFade, blendWeights, blendChannelTextureCoordinates);\n"
"    float2 materialAttributes = Material_Attributes(texCoord, blendWeights, blendChannelTextureCoordinates);\n"
"\n"
"    output.Normal.xyz = normalInView * 0.5 + 0.5;\n"
"        \n"
"    output.Albedo.xyz = albedo.xyz;\n"
"    output.Albedo.w = 1 - materialAttributes.x;\n"
"    \n"
"    float3 normalInWorld = Material_NormalInWorld(normalInView);\n"
"\n"
"    output.Attribute.x = materialAttributes.y;\n"
"    output.Attribute.y = AmbientOcclusionTexture.Sample(SurfaceSampler, texCoord);\n"
"    output.Attribute.z = albedo.w;\n"
"}\n"
"\n"
"#endif // EVA_SURFACE_SHADING\n"
"\n"
"#if defined(EVA_NO_SURFACE_SHADING) && !defined(EVA_DEPTH_ONLY)\n"
"// Inputs:\n"
"// float3 NormalInView : NormalInView;\n"
"//\n"
"// Outputs:\n"
"// float3 Normal : SV_Target0;\n"
"// float3 Diffuse : SV_Target1;\n"
"// float4 Specular : SV_Target2;\n"
"//\n"
"// Constants:\n"
"// uint FullCoverage;\n"
"//\n"
"// Notes:\n"
"// input coverage is provided from ApplyAlphaTestClipping function.\n"
"//\n"
"void ApplySurfaceShading(\n"
"    PixelInput input,\n"
"    uint coverage,\n"
"    inout PixelOutput output,\n"
"    out float3 normalInView)\n"
"{\n"
"    normalInView = input.NormalInView;\n"
"    output.Normal.xyz = normalInView * 0.5 + 0.5;\n"
"    // Is this used?\n"
"    //output.Normal.w = (coverage != FullCoverage);\n"
"}\n"
"#endif // EVA_NO_SURFACE_SHADING && !EVA_DEPTH_ONLY\n"
"\n"
"#if defined(EVA_NO_SURFACE_SHADING) && defined(EVA_DEPTH_ONLY)\n"
"// Depth only, propably with alpha testing, so empty function.\n"
"void ApplySurfaceShading(\n"
"    PixelInput input,\n"
"    uint coverage,\n"
"    inout PixelOutput output,\n"
"    out float3 normalInView)\n"
"{\n"
"    normalInView = 0;\n"
"}\n"
"#endif // EVA_NO_SURFACE_SHADING && EVA_DEPTH_ONLY\n"
"\n"
"\n"
"#ifdef EVA_GLASS_SURFACE_SHADING\n"
"DM_GFX_VK_BINDING(1, 3)\n"
"Texture2D<float4> DiffuseTexture : register(EVA_REGISTER_SRV_MATERIAL_DIFFUSE);\n"
"DM_GFX_VK_BINDING(2, 3)\n"
"Texture2D<float2> AttributeTexture : register(EVA_REGISTER_SRV_MATERIAL_SURFACE_ATTRIBUTES);\n"
"DM_GFX_VK_BINDING(3, 3)\n"
"Texture2D<float2> NormalTexture : register(EVA_REGISTER_SRV_MATERIAL_NORMAL);\n"
"\n"
"#ifndef EVA_ALPHA_TEST\n"
"DM_GFX_VK_BINDING(6, 3)\n"
"Texture2D<float> AlphaTexture : register(EVA_REGISTER_SRV_MATERIAL_ALPHA);\n"
"#endif\n"
"\n"
"// Culling data\n"
"DM_GFX_VK_BINDING(1, 1)\n"
"Buffer<uint> TiledCullingConstantsAndOmniBuffer : register(t0, EVA_REGISTER_SPACE_ILLUMINATION);\n"
"// Buffer<uint> TiledCullingUnshadowedFrustumBuffer: register(t1, EVA_REGISTER_SPACE_ILLUMINATION);\n"
"// Buffer<uint> TiledCullingShadowedFrustumBuffer: register(t2, EVA_REGISTER_SPACE_ILLUMINATION);\n"
"DM_GFX_VK_BINDING(4, 1)\n"
"Buffer<uint> TiledCullingReflectionCapturerBuffer : register(t3, EVA_REGISTER_SPACE_ILLUMINATION);\n"
"\n"
"// Reflection capturer data\n"
"DM_GFX_VK_BINDING(5, 1)\n"
"StructuredBuffer<PackedReflectionCapturerData> ReflectionCapturerBuffer : register(t4, EVA_REGISTER_SPACE_ILLUMINATION);\n"
"DM_GFX_VK_BINDING(6, 1)\n"
"TextureCube<float4> ReflectionCapturerCubes[64] : register(t5, EVA_REGISTER_SPACE_ILLUMINATION);\n"
"\n"
"// Head for link\n"
"DM_GFX_VK_BINDING(70, 1)\n"
"RWByteAddressBuffer ABufferFragmentBufferCounter : register(u0);\n"
"DM_GFX_VK_BINDING(71, 1)\n"
"RWStructuredBuffer<ABufferFragment> ABufferFragmentBuffer : register(u1);\n"
"DM_GFX_VK_BINDING(72, 1)\n"
"RWByteAddressBuffer ABufferHeadPointerBuffer : register(u2);\n"
"\n"
"void LoadSurfaceAttributes(out SurfaceAttributes surface, PixelInput input, float3 position, float2 texCoord, float depth)\n"
"{\n"
"    surface.Depth = depth;\n"
"    \n"
"    float4 PositionInViewH = mul(GetTargetToViewMatrix(ViewConstants), float4(position.xy, depth, 1));\n"
"    surface.PositionInView = input.PositionInView;//PositionInViewH.xyz / PositionInViewH.w;\n"
"\n"
"    float3x3 tangentToViewMatrix = transpose(float3x3(\n"
"        normalize(input.TangentInView), \n"
"        normalize(input.BitangentInView),\n"
"        normalize(input.NormalInView)));\n"
"        \n"
"    float3 normalInView = mul(tangentToViewMatrix, UnpackNormal(NormalTexture, SurfaceSampler, texCoord));\n"
"\n"
"    surface.Normal = normalize(normalInView);\n"
"    float2 attributes = AttributeTexture.Sample(SurfaceSampler, texCoord);\n"
"    surface.Roughness = 1. - attributes.r;\n"
"}\n"
"\n"
"void ApplySurfaceShading(\n"
"    PixelInput input,\n"
"    uint coverage,\n"
"    inout PixelOutput output,\n"
"    out float3 normalInView)\n"
"{\n"
"    float alpha = AlphaTexture.Sample(SurfaceSampler, input.TexCoord.xy) * Transparency;\n"
"\n"
"    if (alpha >= (1.0 / 255.f))\n"
"    {\n"
"        uint2 positionInTarget = input.Position.xy;\n"
"        // TODO: don't use hardcoded values\n"
"        uint2 tileIndex = uint2(positionInTarget.x / 16, positionInTarget.y / 16);\n"
"        uint flattenedTileIndex = tileIndex.x + (uint)ceil(ViewConstants.TargetSize.x / 16)  * tileIndex.y;\n"
"\n"
"        SurfaceAttributes surface;\n"
"        LoadSurfaceAttributes(surface, input, input.Position.xyz, input.TexCoord.xy, input.Position.z / input.Position.w);\n"
"\n"
"        float3 AccumulatedReflection = AccumulateReflections(flattenedTileIndex, ViewConstants.ViewToWorldMatrix, \n"
"            surface, SurfaceSampler,\n"
"            TiledCullingConstantsAndOmniBuffer, TiledCullingReflectionCapturerBuffer,\n"
"            ReflectionCapturerCubes, ReflectionCapturerBuffer\n"
"        );\n"
"\n"
"        float3 eyeDirectionInView = normalize(surface.PositionInView);\n"
"        // Glass should reflect about 4% of light when viewed directly\n"
"        float3 Rf0_0 = float3(0.041869f, 0.042680f, 0.042998f);\n"
"        // combined reflectance (without interference)\n"
"        float3 Rf0 = 2.0f * Rf0_0 / (1.0f + Rf0_0);\n"
"        float n_dot_v = abs(dot(surface.Normal.xyz, eyeDirectionInView));\n"
"        // Fresnel for reflection intensity\n"
"        float3 reflectionIntensity = Rf0 + (1.0 - Rf0) * pow(1.0 - n_dot_v, 5.0);\n"
"    \n"
"        // Depending on the surface angle reduce transmitting light\n"
"        float3 multi_alpha = min(1, alpha + reflectionIntensity);\n"
"\n"
"        // Rough surfaces scatter more light even when viewed directly\n"
"        float3 diffuseColor = AccumulatedReflection * GlassReflectionIntensity * min(1, reflectionIntensity + surface.Roughness); \n"
"\n"
"        // NOTE: A-buffer uses premultiplied alpha, so multiply color with alpha to get the correct blending\n"
"        ABufferFragment fragment = PackABufferFragment(diffuseColor * multi_alpha, dot(multi_alpha, float3(0.2126f, 0.7152f, 0.0722f)), input.Position.z);\n"
"        StoreABufferFragment(positionInTarget, ViewConstants.TargetSize.x, fragment, ABufferFragmentBufferCounter, ABufferFragmentBuffer, ABufferHeadPointerBuffer);\n"
"\n"
"        normalInView = input.NormalInView * 0.5 + 0.5;\n"
"    }\n"
"}\n"
"#endif // EVA_GLASS_SURFACE_SHADING\n"
"\n"
"#ifdef EVA_TRANPARENCY_SURFACE_SHADING\n"
"\n"
"Texture2D<float4> DiffuseTexture : register(EVA_REGISTER_SRV_MATERIAL_DIFFUSE);\n"
"Texture2D<float2> AttributeTexture : register(EVA_REGISTER_SRV_MATERIAL_SURFACE_ATTRIBUTES);\n"
"Texture2D<float2> NormalTexture : register(EVA_REGISTER_SRV_MATERIAL_NORMAL);\n"
"Texture2D<float> AlphaTexture : register(EVA_REGISTER_SRV_MATERIAL_ALPHA);\n"
"\n"
"// Head for link\n"
"DM_GFX_VK_BINDING(17, 1)\n"
"RWByteAddressBuffer ABufferFragmentBufferCounter : register(u0);\n"
"DM_GFX_VK_BINDING(18, 1)\n"
"RWStructuredBuffer<ABufferFragment> ABufferFragmentBuffer : register(u1);\n"
"DM_GFX_VK_BINDING(19, 1)\n"
"RWByteAddressBuffer ABufferHeadPointerBuffer : register(u2);\n"
"\n"
"void ApplySurfaceShading(\n"
"    PixelInput input,\n"
"    uint coverage,\n"
"    inout PixelOutput output,\n"
"    out float3 normalInView)\n"
"{\n"
"    float alpha = AlphaTexture.Sample(SurfaceSampler, input.TexCoord.xy) * Transparency;\n"
"    uint2 positionInTarget = input.Position.xy; \n"
"    float3 diffuseColor = DiffuseTexture.Sample(SurfaceSampler, input.TexCoord.xy).xyz * DiffuseColor;\n"
"    \n"
"    // NOTE: A-buffer uses premultiplied alpha, so multiply color with alpha to get the correct blending\n"
"    ABufferFragment fragment = PackABufferFragment(diffuseColor * alpha, alpha, input.Position.z);\n"
"    StoreABufferFragment(positionInTarget, ViewConstants.TargetSize.x, fragment, ABufferFragmentBuffer, ABufferHeadPointerBuffer);\n"
"    \n"
"    normalInView =  input.NormalInView * 0.5 + 0.5;\n"
"}\n"
"\n"
"#endif // EVA_TRANPARENCY_SURFACE_SHADING\n"
"\n"
"#endif // EVA_GEOMETRY_MATERIAL_SURFACE_SHADING_HLSL\n"
"[earlydepthstencil]\n"
"void main(PixelInput input)\n"
"{\n"
"    PixelOutput output;\n"
"\n"
"#line 12 \"materials.xml\"\n"
"\n"
"output = (PixelOutput)0;\n"
"\n"
"// UV Animation\n"
"EvaluateUVAnimation(input);\n"
"\n"
"// Alpha test\n"
"uint coverage;\n"
"ApplyAlphaTestClipping(input, output, coverage);\n"
"\n"
"// Surface Shading\n"
"float3 normalInView;\n"
"ApplySurfaceShading(input, coverage, output, normalInView);\n"
"\n"
"// Velocity\n"
"//ApplyVelocity(input, output);\n"
"\n"
"// Luminance\n"
"ApplyLuminance(input, normalInView, output);\n"
"\n"
"}\n"
"\n"
""
;